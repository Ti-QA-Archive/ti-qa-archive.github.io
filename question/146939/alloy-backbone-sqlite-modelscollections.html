<!doctype html>
<html>
<head>
	<meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<meta charset="utf-8">
	
		<title>Alloy Backbone SQLite Models/Collections » Community Questions &amp; Answers » Appcelerator Developer Center</title>
	
	<meta name="viewport" content="width=device-width,initial-scale=1">
	<link href="../../related/favicon.png" rel="shortcut icon" type="image/png">
	<link href="//fonts.googleapis.com/css?family=Open+Sans:300,400,500,600,700" rel="stylesheet" type="text/css">
	<link href="//d3ilu1xuwhtfe2.cloudfront.net/e8e0ebd/css/style.css" rel="stylesheet" type="text/css">
	<link href="../../related/qa.css" rel="stylesheet" type="text/css">
	<link href="../../related/hybrid.css" rel="stylesheet" type="text/css">
	
	<link href="../../related/overrides.css" rel="stylesheet" type="text/css">
</head>
<body>

<div class='mast'>    <div class='container'>        <div class='row'>            <div class='col-sm-12'>                <div class='masthead'><h1>Titanium Community Questions & Answer Archive</h1><h2>We felt that 6+ years of knowledge should not die so this is the Titanium Community Questions &amp; Answer Archive</h2></div>            </div>        </div>    </div></div>

<main class="container">
	<div class="row">
		<div class="col-sm-12">
			
		</div>
	</div>
	<div class="row">
		<div class="col-sm-12">
			<article class="question-container">
	<div class="question">
		<header>
			<h1>Alloy Backbone SQLite Models/Collections</h1>
		</header>
		<section>
			<p>I&#39;m new to Alloy&#x2F;Backbone and I&#39;m a little confused about the best way to populate and access an SQLite table in Alloy.</p>
<ol>
<li><p>Is there a way to specify my own table ID (and type) rather than having Alloy&#x2F;Backbone automatically append a typeless &#39;id&#39; field into my table when it auto-runs its <code>CREATE TABLE IF NOT EXISTS</code> statement?<br>How does specifying an <code>idAttribute</code> in the Models config affect this?</p>
</li>
<li><p>What&#39;s the reasoning behind the hash style default id&#39;s e.g. <code>5f8643ab-3c67-d26c-6caa-06406a8e9094</code>. Is it possible to use an auto-incrementing Primary Key instead?</p>
</li>
<li><p>Is there a way to prepopulate the Model&#39;s config <code>&amp;#39;columns&amp;#39;: {}</code> field names&#x2F;types using an existing SQLite DB? I see the <a href="https:&#x2F;&#x2F;github.com&#x2F;appcelerator&#x2F;alloy&#x2F;blob&#x2F;master&#x2F;test&#x2F;apps&#x2F;models&#x2F;sql_preload&#x2F;models&#x2F;fighters.js">sql_preload</a> example uses an existing database to prepopulate rows but not fields.<br>Is it possible to inform Backbone&#x2F;Alloy to us an alternate DB&#x2F;Table entirely rather than creating it&#39;s own inside the auto-generated <code>_alloy_.sql</code> file? I see brief mention to this in the commit comments <a href="https:&#x2F;&#x2F;github.com&#x2F;appcelerator&#x2F;alloy&#x2F;commit&#x2F;981cf8067cdcdadd3af487d1b120c69ab392ba13">here</a> as a possible upcomming feature?</p>
</li>
<li><p>What&#39;s the best way to get a single Model from a Collection based on a field other than it&#39;s ID? The equivalent of a <code>SELECT * FROM table WHERE myField=value</code>.<br>I see I can filter the entire result set using <code>collection.where({myField: value})[0]</code> but that doesn&#39;t seem efficient?<br><code>collection.get(&amp;#39;5f8643ab-3c67-d26c-6caa-06406a8e9094&amp;#39;)</code> works but I have no idea how I&#39;m supposed to know the automatic ID unless I sync&#x2F;store it somewhere which seems like unnecessary extra work. <code>collection.get({myField: value})</code> would be nice but doesn&#39;t seem supported.</p>
</li>
</ol>
<p>Cheers for any light shed no these issues.</p>

		</section>
		<footer>
			<div class="author">
				&mdash; asked <span title="January 16th 2013, 2:41:48 am">January 16th 2013</span>
				by <span class='authorname'>Tim Keir</span>
			</div>

			
				<ul class="tags">
					
						<li><span class='tagname'>alloy</span></li>
					
						<li><span class='tagname'>backbone</span></li>
					
						<li><span class='tagname'>collection</span></li>
					
						<li><span class='tagname'>model</span></li>
					
						<li><span class='tagname'>sqlite</span></li>
					
				</ul>
			

			<section>
				<h5>1 Comment</h5>
				
					<ul class="comments">
					
						<li class="comment">
							<div><p>OK after further searching it seems Alloy Models don&#39;t support an auto-incrementing primary key (or custom ID&#39;s) yet. <a href="https:&#x2F;&#x2F;jira.appcelerator.org&#x2F;browse&#x2F;ALOY-447">ALOY-447</a>. More info in the comments <a href="http:&#x2F;&#x2F;developer.appcelerator.com&#x2F;question&#x2F;146207&#x2F;relationships-in-alloy-models">here</a></p>
</div>
							<div class="author">
								&mdash; commented <span title="January 16th 2013, 3:10:55 am">January 16th 2013</span>
								by <span class='authorname'>Tim Keir</span>
							</div>
						</li>
					
					</ul>
				
			</section>
		</footer>
		<aside class="vote-box vote-box-answered">
			<div class="score"><span>0</span> Votes</div>
			<div class="answers"><span>3</span> Answers</div>
		</aside>
	</div>

	<hr>

	<h3>3 Answers</h3>

	
		<ul class="answers">
			
				<li class="answer">
				
					<article class="accepted-answer" id="answer-254689">
						<header>
							<h2><span class="icon-bg icon-check-1"></span>Accepted Answer</h2>
						</header>
				
						<section>
							<p>OK, here&#39;s the answers I have for you so far:</p>
<p><strong>1)</strong> You will soon be able to specify a new column in your sql database definition as the ID, likely in the next released version of Alloy, but you can&#39;t really do it right now as the &quot;id&quot; field is assumed to be present. The <strong>idAttribute</strong> tells your Backbone model which field uniquely identifies it for update and delete operations. It is &quot;id&quot; by default. Once you are able to specify a new unique identifier field in your sql database definition, you&#39;ll then set your model&#39;s idAttribute to the same name as that field to inform Backbone what to use to uniquely identify it. The <strong>idAttribute</strong>, again &quot;id&quot; by default, is the main point of coupling between Backbone and whatever backend data source you are using to sync records.</p>
<p><strong>2)</strong> GUIDs were used initially because they applied to all adapters we were initially building so it seemed simplest to use them across the board. As the functionality of the sql adapter is now growing, you are likely right that this should instead be changed to use a simple autoincrement primary key field. This update should be relatively transparent to developers.</p>
<p><strong>3)</strong> At the moment, no, but I am currently investigating being able to populate the <strong>columns</strong> based on the contents of an initial sql database file.</p>
<p><strong>4)</strong> You&#39;ll be able to do custom queries on your fetch() calls in the next version of Alloy. That should give you exactly what you are looking for. Details here: <a href="https:&#x2F;&#x2F;jira.appcelerator.org&#x2F;browse&#x2F;ALOY-458">https:&#x2F;&#x2F;jira.appcelerator.org&#x2F;browse&#x2F;ALOY-458</a>\</p>
<p>PS - Well-timed question, as I am literally working on almost all this stuff this week. :)</p>

						</section>
						<footer>
							<div class="author">
								&mdash; answered <span title="January 16th 2013, 11:56:59 am">January 16th 2013</span>
								by <span class='authorname'>Tony Lukasavage</span><br>
								<a class="icon-bg icon-link" href="question/146939/alloy-backbone-sqlite-modelscollections#answer-254689" rel="permalink">permalink</a>
							</div>

							<h5>7 Comments</h5>
							
								<ul class="comments">
								
									<li class="comment">
										<p><p>Upon further reflection with #2, if a developer does not explicitly pick the idAttribute field (made possible by #1), Alloy will likely continue to automatically use the GUID text field. The reason we can&#39;t just add an integer primary key is that there might already be primary keys on the table and this could screw up a developer&#39;s data integrity. An unrelated, non-primary key text field would safely allow Alloy&#x2F;Backbone to maintain their relationshop with the sqlite db.</p>
<p>Like I said though, soon you&#39;ll be able to specify fields in <strong>columns</strong> as primary key and&#x2F;or autoincrement. At that point, you could disable Alloy&#39;s automatically added <strong>id</strong> field by simply specifying your own <strong>idAttribute</strong> field, like this (not implemented yet in 0.3.4):</p>
<pre><code class="hljs">exports.definition = {
    columns: {
        myId: <span class="hljs-string">'INTEGER PRIMARY KEY AUTOINCREMENT'</span>,
        col2: <span class="hljs-string">'TEXT'</span>,
        col3: <span class="hljs-string">'TEXT'</span>
    },
    adapter: {
        type: <span class="hljs-string">'sql'</span>,
        collection_name: <span class="hljs-string">'myTable'</span>
    },
    idAttribute: <span class="hljs-string">'myId'</span>
}
</code></pre><p>The above would add no additional columns to your database table, no more &quot;id&quot; column tacked on. It would just use <strong>myId</strong> as the unique key between Backbone and sqlite. In any case where <strong>idAttribute</strong> is not specified, though, it will continue to use the text GUID.</p>
</p>
										<div class="author">
											&mdash; commented <span title="January 16th 2013, 3:40:32 pm">January 16th 2013</span>
											by <span class='authorname'>Tony Lukasavage</span>
										</div>
									</li>
								
									<li class="comment">
										<p><p>Thanks for the thorough answers Tony! The upcoming changes sound great. I don&#39;t suppose I can push my luck and ask whether you have an estimated release date? e.g. ~2 weeks? :)</p>
</p>
										<div class="author">
											&mdash; commented <span title="January 16th 2013, 8:06:51 pm">January 16th 2013</span>
											by <span class='authorname'>Tim Keir</span>
										</div>
									</li>
								
									<li class="comment">
										<p><p>Luck successfully pushed: 0.3.5 should be out in the next couple days and it will be debuting the new sql adapter functionality as likely the &quot;sql_new&quot; adapter, leaving the existing sql adapter so everyone&#39;s apps continue to operate as expected. The new sql adapter has enough changes that it may require some minimal migration before devs will hop on to using it. After 1.0, though, &quot;sql_new&quot; will become <em>the</em> &quot;sql&quot; adapter. Those desperate to stay on the old adapter will still be able to grab it from the 0.3.X branch on github, but it will no longer be updated after that. </p>
<p>Also, to fix the above proposed code, it&#39;ll actually be like this:</p>
<pre><code class="hljs">exports.definition = {
    columns: {
        myId: <span class="hljs-string">'INTEGER PRIMARY KEY AUTOINCREMENT'</span>,
        col2: <span class="hljs-string">'TEXT'</span>,
        col3: <span class="hljs-string">'TEXT'</span>
    },
    adapter: {
        type: <span class="hljs-string">'sql'</span>,
        collection_name: <span class="hljs-string">'myTable'</span>,
        idAttribute: <span class="hljs-string">'myId'</span>
    }
}
</code></pre></p>
										<div class="author">
											&mdash; commented <span title="January 16th 2013, 8:54:47 pm">January 16th 2013</span>
											by <span class='authorname'>Tony Lukasavage</span>
										</div>
									</li>
								
									<li class="comment">
										<p><p>Oh, and your request for populating columns from an installed sqlite database, which will be able to be done by simply adding <code>db_file: &amp;#39;&amp;#x2F;path&amp;#x2F;to&amp;#x2F;db.sqlite&amp;#39;</code> to the <strong>definition.adapter</strong> object, will be in there as well. <strong>definition.columns</strong> will not be necessary for configs containing that <strong>db_file</strong> property. :)</p>
</p>
										<div class="author">
											&mdash; commented <span title="January 16th 2013, 8:57:16 pm">January 16th 2013</span>
											by <span class='authorname'>Tony Lukasavage</span>
										</div>
									</li>
								
									<li class="comment">
										<p><p>Awesome news! Thanks a lot Tony! Keep up the good work :D</p>
</p>
										<div class="author">
											&mdash; commented <span title="January 16th 2013, 8:58:46 pm">January 16th 2013</span>
											by <span class='authorname'>Tim Keir</span>
										</div>
									</li>
								
									<li class="comment">
										<p><p>the attribute id can be specified when extending the object, there is no need to wait for an alloy release. idAttribute is part of the standard backboneJS implementation</p>
</p>
										<div class="author">
											&mdash; commented <span title="January 18th 2013, 2:13:41 pm">January 18th 2013</span>
											by <span class='authorname'>Aaron Saunders</span>
										</div>
									</li>
								
									<li class="comment">
										<p><p>Technically he can, you are correct, but the sql adapter, until the next release, will keep adding the then unused &quot;id&quot; field. The &quot;idAttribute&quot; in the model definition, as opposed to in code, will tell alloy to use that field as the unique id column and not create its own like it did in the past.</p>
</p>
										<div class="author">
											&mdash; commented <span title="January 18th 2013, 3:03:30 pm">January 18th 2013</span>
											by <span class='authorname'>Tony Lukasavage</span>
										</div>
									</li>
								
								</ul>
							
						</footer>
						<aside class="vote-box vote-box-answered">
							<div class="score"><span>3</span> Votes</div>
						</aside>
					</article>
				</li>
			
				<li class="answer">
				
					<article id="answer-257353">
				
						<section>
							<p>idAttribute does not work with TEXT:</p>
<pre><code class="hljs"><span class="hljs-string">"columns"</span>: {
           <span class="hljs-string">"consignmentId"</span> : <span class="hljs-string">"TEXT PRIMARY KEY"</span>,
           <span class="hljs-string">"status"</span> : <span class="hljs-string">"TEXT"</span>
        },
        <span class="hljs-string">"defaults"</span>: {
           <span class="hljs-string">"consignmentId"</span> : <span class="hljs-string">"00000000000"</span>,
           <span class="hljs-string">"status"</span> : <span class="hljs-string">"-"</span>
        },
        adapter: {
            type: <span class="hljs-string">"sql"</span>,
            collection_name: <span class="hljs-string">"lastconsignments"</span>,
            idAttribute: <span class="hljs-string">"consignmentId"</span>
        }
</code></pre>
						</section>
						<footer>
							<div class="author">
								&mdash; answered <span title="February 22nd 2013, 10:38:25 am">February 22nd 2013</span>
								by <span class='authorname'>Tommy Leirvik</span><br>
								<a class="icon-bg icon-link" href="question/146939/alloy-backbone-sqlite-modelscollections#answer-257353" rel="permalink">permalink</a>
							</div>

							<h5>6 Comments</h5>
							
								<ul class="comments">
								
									<li class="comment">
										<p><p>When an idAttribute is not specified, Alloy will automatically use a TEXT field GUID as the idAttribute, so there&#39;s lots of cases that use one. Perhaps a test case would better show us what&#39;s going on.</p>
</p>
										<div class="author">
											&mdash; commented <span title="February 22nd 2013, 10:47:40 am">February 22nd 2013</span>
											by <span class='authorname'>Tony Lukasavage</span>
										</div>
									</li>
								
									<li class="comment">
										<p><p>Ok.<br>I try to illustrate what I&#39;m doing without pasting all the code here.</p>
<p>If I run this code below the model are created each time(duplicated) with the model settings I pasted In before.</p>
<pre><code class="hljs"><span class="hljs-keyword">var</span> lastConsignment = Alloy.createModel(<span class="hljs-string">'LastConsignment'</span>);
 lastConsignment.save({
                consignmentId: <span class="hljs-string">'7777777333333'</span>,
                status: <span class="hljs-string">'Delivered'</span>
            });
            Alloy.Collections.LastConsignment.fetch();
</code></pre></p>
										<div class="author">
											&mdash; commented <span title="February 22nd 2013, 11:16:27 am">February 22nd 2013</span>
											by <span class='authorname'>Tommy Leirvik</span>
										</div>
									</li>
								
									<li class="comment">
										<p><p>I have no way of knowing what is going on in your app without a test case and I&#39;m not really following what you are saying. Don&#39;t paste in your whole app, create a small test case that exhbiits your issue.</p>
</p>
										<div class="author">
											&mdash; commented <span title="February 22nd 2013, 11:31:58 am">February 22nd 2013</span>
											by <span class='authorname'>Tony Lukasavage</span>
										</div>
									</li>
								
									<li class="comment">
										<p><p>Ok. I created a example below. The problem are that when i create a model with the same idAttributes It&#39;s created and not updated&#x2F;ignored.</p>
<p>In index.js(controller):</p>
<pre><code class="hljs">$.index.open();

Alloy.Collections.Test.fetch();

$.CreateTest.addEventListener(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">_e</span>)</span>{
    <span class="hljs-keyword">var</span> test = Alloy.createModel(<span class="hljs-string">'Test'</span>);
    test.save({
        customStringId : <span class="hljs-string">'777777777777'</span>
    });
    Alloy.Collections.Test.fetch();
});
</code></pre><p>In index.xml(view):</p>
<pre><code class="hljs"><span class="hljs-tag">&lt;<span class="hljs-title">Alloy</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">Collection</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">"Test"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">Window</span> <span class="hljs-attribute">navBarHidden</span>=<span class="hljs-value">"true"</span> <span class="hljs-attribute">tabBarHidden</span>=<span class="hljs-value">"true"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">Button</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"CreateTest"</span> <span class="hljs-attribute">title</span>=<span class="hljs-value">"CreateTest"</span> <span class="hljs-attribute">top</span>=<span class="hljs-value">"0"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">TableView</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"testTable"</span> <span class="hljs-attribute">dataCollection</span>=<span class="hljs-value">"Test"</span> <span class="hljs-attribute">top</span>=<span class="hljs-value">"50"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-title">TableViewRow</span> <span class="hljs-attribute">title</span>=<span class="hljs-value">"{customStringId}"</span> /&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-title">TableView</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-title">Window</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">Alloy</span>&gt;</span>
</code></pre><p>In Test.js(model):</p>
<pre><code class="hljs">exports.definition = {  
    config: {
        <span class="hljs-string">"columns"</span>:{
            <span class="hljs-string">"customStringId"</span>: <span class="hljs-string">"TEXT PRIMARY KEY"</span>
        },
        <span class="hljs-string">"defaults"</span>: {
            <span class="hljs-string">"customStringId"</span>: <span class="hljs-string">"777777777777"</span>
        },
        <span class="hljs-string">"adapter"</span>: {
            <span class="hljs-string">"type"</span>: <span class="hljs-string">"sql"</span>,
            <span class="hljs-string">"collection_name"</span>: <span class="hljs-string">"tests"</span>,
            <span class="hljs-string">"idAttribute"</span>: <span class="hljs-string">"customStringId"</span>
        }
    },
    extendModel: function(Model) {      
        <span class="hljs-number">_</span>.extend(Model.prototype, {});
        return Model;
    },  
    extendCollection: function(Collection) {        
        <span class="hljs-number">_</span>.extend(Collection.prototype, {});
        return Collection;
    }
}
</code></pre></p>
										<div class="author">
											&mdash; commented <span title="February 22nd 2013, 11:50:08 am">February 22nd 2013</span>
											by <span class='authorname'>Tommy Leirvik</span>
										</div>
									</li>
								
									<li class="comment">
										<p><p>Well, you wouldn&#39;t want to create a new model with the same idAttribute value. What;s happening would be the expected behavior in that case. You should be operating on the existing instance of the model that holds that id. If that model was present in a collection, you would get it like this:</p>
<pre><code class="hljs"><span class="hljs-variable"><span class="hljs-keyword">var</span> theModel</span> = collection.<span class="hljs-keyword">get</span>(<span class="hljs-string">"777777777777"</span>);
<span class="hljs-comment">// now you can set() and save() values and they will get updated</span>
</code></pre></p>
										<div class="author">
											&mdash; commented <span title="February 22nd 2013, 12:54:38 pm">February 22nd 2013</span>
											by <span class='authorname'>Tony Lukasavage</span>
										</div>
									</li>
								
									<li class="comment">
										<p><p>@Tony the sql adapter should be updating the model not creating a new one…. in <strong>think</strong> this is a bug in the adapter that we were discussing a few weeks ago.</p>
</p>
										<div class="author">
											&mdash; commented <span title="February 25th 2013, 9:06:39 pm">February 25th 2013</span>
											by <span class='authorname'>Aaron Saunders</span>
										</div>
									</li>
								
								</ul>
							
						</footer>
						<aside class="vote-box">
							<div class="score"><span>0</span> Votes</div>
						</aside>
					</article>
				</li>
			
				<li class="answer">
				
					<article id="answer-257481">
				
						<section>
							<p>Ok, I hoped that the db layer took care of this since when you got an primary key in regular sql then you get an error when inserting one with the same value.</p>
<p>If you see below I have a solution to the problem, but If you have another solution I would like to her about it! :)</p>
<pre><code class="hljs"> <span class="hljs-keyword">var</span> exits = <span class="hljs-literal">false</span>;
        Alloy.Collections.LastConsignment.map(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(consignment)</span></span>{
            <span class="hljs-keyword">var</span> cid = consignment.<span class="hljs-keyword">get</span>(<span class="hljs-string">'consignmentId'</span>);
            <span class="hljs-keyword">if</span>(cid == _model[<span class="hljs-number">0</span>].shipmentId){
                exits = <span class="hljs-literal">true</span>;
            }
        });

        <span class="hljs-keyword">if</span>(exits){
            <span class="hljs-keyword">var</span> lastConsignment = Alloy.Collections.LastConsignment.<span class="hljs-keyword">get</span>(_model[<span class="hljs-number">0</span>].shipmentId);
        }
        <span class="hljs-keyword">else</span>{
            <span class="hljs-keyword">var</span> lastConsignment = Alloy.createModel(<span class="hljs-string">'LastConsignment'</span>);
        }

        <span class="hljs-keyword">if</span>(Alloy.Collections.Consignment.results == <span class="hljs-number">1</span>){
            lastConsignment.<span class="hljs-keyword">set</span>({
                consignmentId: _model[<span class="hljs-number">0</span>].shipmentId,
                status: _model[<span class="hljs-number">0</span>].statusText.header
            }); 
        }
        <span class="hljs-keyword">else</span>{
            lastConsignment.<span class="hljs-keyword">set</span>({
                consignmentId: $.q.value,
                status:  <span class="hljs-string">'Flere treff'</span>
            });
        }

        lastConsignment.save();
        Alloy.Collections.LastConsignment.reset();
        Alloy.Collections.LastConsignment.fetch();
</code></pre>
						</section>
						<footer>
							<div class="author">
								&mdash; answered <span title="February 25th 2013, 8:38:01 am">February 25th 2013</span>
								by <span class='authorname'>Tommy Leirvik</span><br>
								<a class="icon-bg icon-link" href="question/146939/alloy-backbone-sqlite-modelscollections#answer-257481" rel="permalink">permalink</a>
							</div>

							<h5>0 Comments</h5>
							
						</footer>
						<aside class="vote-box">
							<div class="score"><span>0</span> Votes</div>
						</aside>
					</article>
				</li>
			
		</ul>
	
</article>

		</div>
		<div class="col-sm-3"></div>
	</div>
	<div class="row"><div class="signoff">The ownership of individual contributions to this community generated content is retained by the authors of their contributions.<br>All trademarks remain the property of the respective owner.</div></div>
</main>


</body>
</html>
