<!doctype html>
<html>
<head>
	<meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<meta charset="utf-8">
	
		<title>jsPDF with Titanium iPad » Community Questions &amp; Answers » Appcelerator Developer Center</title>
	
	<meta name="viewport" content="width=device-width,initial-scale=1">
	<link href="../../related/favicon.png" rel="shortcut icon" type="image/png">
	<link href="//fonts.googleapis.com/css?family=Open+Sans:300,400,500,600,700" rel="stylesheet" type="text/css">
	<link href="//d3ilu1xuwhtfe2.cloudfront.net/e8e0ebd/css/style.css" rel="stylesheet" type="text/css">
	<link href="../../related/qa.css" rel="stylesheet" type="text/css">
	<link href="../../related/hybrid.css" rel="stylesheet" type="text/css">
	
	<link href="../../related/overrides.css" rel="stylesheet" type="text/css">
</head>
<body>

<div class='mast'>    <div class='container'>        <div class='row'>            <div class='col-sm-12'>                <div class='masthead'><h1>Titanium Community Questions & Answer Archive</h1><h2>We felt that 6+ years of knowledge should not die so this is the Titanium Community Questions &amp; Answer Archive</h2></div>            </div>        </div>    </div></div>

<main class="container">
	<div class="row">
		<div class="col-sm-12">
			
		</div>
	</div>
	<div class="row">
		<div class="col-sm-12">
			<article class="question-container">
	<div class="question">
		<header>
			<h1>jsPDF with Titanium iPad</h1>
		</header>
		<section>
			<p>I m trying to use the jspdf module with titanium iPad, problem is when i try and include the jspdf.js file in my titanium project i get the error</p>
<p><code>[ERROR] Script Error = Can&amp;#39;t find variable: window at jspdf.js (line 47).</code></p>
<p>When i see line 47 i get this code</p>
<p><code>if (typeof btoa === &amp;#39;undefined&amp;#39;) 
{
        window.btoa = function (data) 
    {</code></p>
<p>Any help would be appreciated.</p>

		</section>
		<footer>
			<div class="author">
				&mdash; asked <span title="May 13th 2013, 2:55:12 am">May 13th 2013</span>
				by <span class='authorname'>Abhishek Sharma</span>
			</div>

			
				<ul class="tags">
					
						<li><span class='tagname'>jspdf, titanium ipad</span></li>
					
				</ul>
			

			<section>
				<h5>1 Comment</h5>
				
					<ul class="comments">
					
						<li class="comment">
							<div><p>Could you please post your full code or how you initialise the window will be useful to find what is wrong there.</p>
</div>
							<div class="author">
								&mdash; commented <span title="May 13th 2013, 2:57:28 am">May 13th 2013</span>
								by <span class='authorname'>Manoj Kumar M</span>
							</div>
						</li>
					
					</ul>
				
			</section>
		</footer>
		<aside class="vote-box vote-box-answered">
			<div class="score"><span>0</span> Votes</div>
			<div class="answers"><span>3</span> Answers</div>
		</aside>
	</div>

	<hr>

	<h3>3 Answers</h3>

	
		<ul class="answers">
			
				<li class="answer">
				
					<article class="accepted-answer" id="answer-262604">
						<header>
							<h2><span class="icon-bg icon-check-1"></span>Accepted Answer</h2>
						</header>
				
						<section>
							<p>jsPDF is a javascript library for HTML5 clients. In other words it requires a web browser to operate.  That is why it is complaining about not finding the <code>window</code> object that is exposed by the browser DOM.</p>

						</section>
						<footer>
							<div class="author">
								&mdash; answered <span title="May 13th 2013, 6:46:40 am">May 13th 2013</span>
								by <span class='authorname'>Nick Milner</span><br>
								<a class="icon-bg icon-link" href="question/152278/jspdf-with-titanium-ipad#answer-262604" rel="permalink">permalink</a>
							</div>

							<h5>0 Comments</h5>
							
						</footer>
						<aside class="vote-box vote-box-answered">
							<div class="score"><span>0</span> Votes</div>
						</aside>
					</article>
				</li>
			
				<li class="answer">
				
					<article id="answer-262591">
				
						<section>
							<p>Hi</p>
<p>Abishek usually these type of error comes because of these reasons</p>
<p>1)You have not declared window variable</p>
<p>2)Scope problem</p>
<p>See for these two errors or post the code here</p>
<p>Thanks</p>

						</section>
						<footer>
							<div class="author">
								&mdash; answered <span title="May 13th 2013, 3:06:41 am">May 13th 2013</span>
								by <span class='authorname'>Muhammad Wahhab Mirza</span><br>
								<a class="icon-bg icon-link" href="question/152278/jspdf-with-titanium-ipad#answer-262591" rel="permalink">permalink</a>
							</div>

							<h5>0 Comments</h5>
							
						</footer>
						<aside class="vote-box">
							<div class="score"><span>0</span> Votes</div>
						</aside>
					</article>
				</li>
			
				<li class="answer">
				
					<article id="answer-262593">
				
						<section>
							<p>Hi Manoj,</p>
<p>This is my app.js</p>
<pre><code class="hljs">var win = Ti.UI.createWindow({
    backgroundColor: <span class="hljs-string">'white'</span>
});

var btn = Ti.UI.createButton({
    title: <span class="hljs-string">'Generate PDF'</span>,
    left: <span class="hljs-number">100</span>,
    top: <span class="hljs-number">100</span>,
    <span class="hljs-variable">width</span>: Ti.UI.SIZE,
    <span class="hljs-variable">height</span>: Ti.UI.SIZE
});

btn.addEventListener(<span class="hljs-string">'click'</span>,function(e)
{
    <span class="hljs-keyword">try</span>
    {
        Ti.include(Ti.Filesystem.resourcesDirectory+<span class="hljs-string">'jsPDF-master/jspdf.js'</span>);
        doc = <span class="hljs-keyword">new</span> jspdf();
        doc.<span class="hljs-built_in">text</span>(<span class="hljs-number">20</span>, <span class="hljs-number">20</span>, <span class="hljs-string">'Hello world!'</span>);
        doc.<span class="hljs-built_in">text</span>(<span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-string">'This is client-side Javascript, pumping out a PDF.'</span>);
        doc.addPage();
        doc.<span class="hljs-built_in">text</span>(<span class="hljs-number">20</span>, <span class="hljs-number">20</span>, <span class="hljs-string">'Do you like that?'</span>);        
    }
    <span class="hljs-keyword">catch</span>(e)
    {
        alert(e);
    }
});
win.<span class="hljs-built_in">add</span>(btn);
win.<span class="hljs-built_in">open</span>();
</code></pre><p>And this is my folder structure.<br>I have copied the jspdf-master folder in my resources directory.</p>
<p><img src="&#x2F;Users&#x2F;abhisheksharma&#x2F;Desktop&#x2F;struct.png &quot;Project Structure&quot;" alt="Structure"></p>

						</section>
						<footer>
							<div class="author">
								&mdash; answered <span title="May 13th 2013, 3:13:01 am">May 13th 2013</span>
								by <span class='authorname'>Abhishek Sharma</span><br>
								<a class="icon-bg icon-link" href="question/152278/jspdf-with-titanium-ipad#answer-262593" rel="permalink">permalink</a>
							</div>

							<h5>2 Comments</h5>
							
								<ul class="comments">
								
									<li class="comment">
										<p><p>Plz paste the code of JSPDF here and one tip plz try to comment in the area instead of making the new answer</p>
<p>Thanks</p>
</p>
										<div class="author">
											&mdash; commented <span title="May 13th 2013, 3:34:53 am">May 13th 2013</span>
											by <span class='authorname'>Muhammad Wahhab Mirza</span>
										</div>
									</li>
								
									<li class="comment">
										<p><p>~~~<br>&#x2F;<em>* @preserve jsPDF 0.9.0rc2 ( ${buildDate} ${commitID} )<br>Copyright (c) 2010-2012 James Hall, james@snapshotmedia.co.uk, https:&#x2F;&#x2F;github.com&#x2F;MrRio&#x2F;jsPDF<br>Copyright (c) 2012 Willow Systems Corporation, willow-systems.com<br>MIT license.
</em>&#x2F;</p>
<p>&#x2F;*</p>
<ul>
<li>Permission is hereby granted, free of charge, to any person obtaining</li>
<li>a copy of this software and associated documentation files (the</li>
<li>&quot;Software&quot;), to deal in the Software without restriction, including</li>
<li>without limitation the rights to use, copy, modify, merge, publish,</li>
<li>distribute, sublicense, and&#x2F;or sell copies of the Software, and to</li>
<li>permit persons to whom the Software is furnished to do so, subject to</li>
<li>the following conditions:<br>*</li>
<li>The above copyright notice and this permission notice shall be</li>
<li>included in all copies or substantial portions of the Software.<br>*</li>
<li>THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,</li>
<li>EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</li>
<li>MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND</li>
<li>NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE</li>
<li>LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION</li>
<li>OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION</li>
<li>WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</li>
<li>====================================================================<br>*&#x2F;</li>
</ul>
<p>&#x2F;<em>*<br>Creates new jsPDF document object instance<br>@class<br>@param orientation One of &quot;portrait&quot; or &quot;landscape&quot; (or shortcuts &quot;p&quot; (Default), &quot;l&quot;)<br>@param unit Measurement unit to be used when coordinates are specified. One of &quot;pt&quot; (points), &quot;mm&quot; (Default), &quot;cm&quot;, &quot;in&quot;<br>@param format One of &#39;a3&#39;, &#39;a4&#39; (Default),&#39;a5&#39; ,&#39;letter&#39; ,&#39;legal&#39;<br>@returns {jsPDF}<br>@name jsPDF
</em>&#x2F;<br>var jsPDF = (function () {<br>    &#39;use strict&#39;;<br>    &#x2F;<em>jslint browser:true, plusplus: true, bitwise: true, nomen: true </em>&#x2F;<br>    &#x2F;<em>global document: false, btoa, atob, zpipe, Uint8Array, ArrayBuffer, Blob, saveAs, adler32cs, Deflater </em>&#x2F;</p>
<p>&#x2F;&#x2F; this will run on &lt;=IE9, possibly some niche browsers<br>&#x2F;&#x2F; new webkit-based, FireFox, IE10 already have native version of this.<br>    if (typeof btoa === &#39;undefined&#39;) {<br>        window.btoa = function (data) {<br>        &#x2F;&#x2F; DO NOT ADD UTF8 ENCODING CODE HERE!!!!</p>
<pre><code class="hljs">    <span class="hljs-comment">// UTF8 encoding encodes bytes over char code 128</span>
    <span class="hljs-comment">// and, essentially, turns an 8-bit binary streams</span>
    <span class="hljs-comment">// (that base64 can deal with) into 7-bit binary streams.</span>
    <span class="hljs-comment">// (by default server does not know that and does not recode the data back to 8bit)</span>
    <span class="hljs-comment">// You destroy your data.</span>

    <span class="hljs-comment">// binary streams like jpeg image data etc, while stored in JavaScript strings,</span>
    <span class="hljs-comment">// (which are 16bit arrays) are in 8bit format already.</span>
    <span class="hljs-comment">// You do NOT need to char-encode that before base64 encoding.</span>

    <span class="hljs-comment">// if you, by act of fate</span>
    <span class="hljs-comment">// have string which has individual characters with code</span>
    <span class="hljs-comment">// above 255 (pure unicode chars), encode that BEFORE you base64 here.</span>
    <span class="hljs-comment">// you can use absolutely any approch there, as long as in the end,</span>
    <span class="hljs-comment">// base64 gets an 8bit (char codes 0 - 255) stream.</span>
    <span class="hljs-comment">// when you get it on the server after un-base64, you must</span>
    <span class="hljs-comment">// UNencode it too, to get back to 16, 32bit or whatever original bin stream.</span>

    <span class="hljs-comment">// Note, Yes, JavaScript strings are, in most cases UCS-2 -</span>
    <span class="hljs-comment">// 16-bit character arrays. This does not mean, however,</span>
    <span class="hljs-comment">// that you always have to UTF8 it before base64.</span>
    <span class="hljs-comment">// it means that if you have actual characters anywhere in</span>
    <span class="hljs-comment">// that string that have char code above 255, you need to</span>
    <span class="hljs-comment">// recode *entire* string from 16-bit (or 32bit) to 8-bit array.</span>
    <span class="hljs-comment">// You can do binary split to UTF16 (BE or LE)</span>
    <span class="hljs-comment">// you can do utf8, you can split the thing by hand and prepend BOM to it,</span>
    <span class="hljs-comment">// but whatever you do, make sure you mirror the opposite on</span>
    <span class="hljs-comment">// the server. If server does not expect to post-process un-base64</span>
    <span class="hljs-comment">// 8-bit binary stream, think very very hard about messing around with encoding.</span>

    <span class="hljs-comment">// so, long story short:</span>
    <span class="hljs-comment">// DO NOT ADD UTF8 ENCODING CODE HERE!!!!</span>

    <span class="hljs-comment">/* @preserve
    ====================================================================
    base64 encoder
    MIT, GPL

    version: 1109.2015
    discuss at: http://phpjs.org/functions/base64_encode
    +   original by: Tyler Akins (http://rumkin.com)
    +   improved by: Bayron Guevara
    +   improved by: Thunder.m
    +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
    +   bugfixed by: Pellentesque Malesuada
    +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
    +   improved by: Rafal Kukawski (http://kukawski.pl)
    +                Daniel Dotsenko, Willow Systems Corp, willow-systems.com
    ====================================================================
    */</span>

        <span class="hljs-keyword">var</span> b64 = <span class="hljs-string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="</span>,
            b64a = b64.split(<span class="hljs-string">''</span>),
            o1,
            o2,
            o3,
            h1,
            h2,
            h3,
            h4,
            bits,
            i = <span class="hljs-number">0</span>,
            ac = <span class="hljs-number">0</span>,
            enc = <span class="hljs-string">""</span>,
            tmp_arr = [],
            r;

        <span class="hljs-keyword">do</span> { <span class="hljs-comment">// pack three octets into four hexets</span>
            o1 = data.charCodeAt(i++);
            o2 = data.charCodeAt(i++);
            o3 = data.charCodeAt(i++);

            bits = o1 &lt;&lt; <span class="hljs-number">16</span> | o2 &lt;&lt; <span class="hljs-number">8</span> | o3;

            h1 = bits &gt;&gt; <span class="hljs-number">18</span> &amp; <span class="hljs-number">0x3f</span>;
            h2 = bits &gt;&gt; <span class="hljs-number">12</span> &amp; <span class="hljs-number">0x3f</span>;
            h3 = bits &gt;&gt; <span class="hljs-number">6</span> &amp; <span class="hljs-number">0x3f</span>;
            h4 = bits &amp; <span class="hljs-number">0x3f</span>;

            <span class="hljs-comment">// use hexets to index into b64, and append result to encoded string</span>
            tmp_arr[ac++] = b64a[h1] + b64a[h2] + b64a[h3] + b64a[h4];
        } <span class="hljs-keyword">while</span> (i &lt; data.length);

        enc = tmp_arr.join(<span class="hljs-string">''</span>);
        r = data.length % <span class="hljs-number">3</span>;
        <span class="hljs-keyword">return</span> (r ? enc.slice(<span class="hljs-number">0</span>, r - <span class="hljs-number">3</span>) : enc) + <span class="hljs-string">'==='</span>.slice(r || <span class="hljs-number">3</span>);
        <span class="hljs-comment">// end of base64 encoder MIT, GPL</span>
    };
}

<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> atob === <span class="hljs-string">'undefined'</span>) {
    <span class="hljs-built_in">window</span>.atob = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>{
    <span class="hljs-comment">// http://kevin.vanzonneveld.net</span>
    <span class="hljs-comment">// +   original by: Tyler Akins (http://rumkin.com)</span>
    <span class="hljs-comment">// +   improved by: Thunder.m</span>
    <span class="hljs-comment">// +      input by: Aman Gupta</span>
    <span class="hljs-comment">// +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)</span>
    <span class="hljs-comment">// +   bugfixed by: Onno Marsman</span>
    <span class="hljs-comment">// +   bugfixed by: Pellentesque Malesuada</span>
    <span class="hljs-comment">// +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)</span>
    <span class="hljs-comment">// +      input by: Brett Zamir (http://brett-zamir.me)</span>
    <span class="hljs-comment">// +   bugfixed by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)</span>
    <span class="hljs-comment">// *     example 1: base64_decode('S2V2aW4gdmFuIFpvbm5ldmVsZA==');</span>
    <span class="hljs-comment">// *     returns 1: 'Kevin van Zonneveld'</span>
    <span class="hljs-comment">// mozilla has this native</span>
    <span class="hljs-comment">// - but breaks in 2.0.0.12!</span>
    <span class="hljs-comment">//if (typeof this.window['atob'] == 'function') {</span>
    <span class="hljs-comment">//    return atob(data);</span>
    <span class="hljs-comment">//}</span>
        <span class="hljs-keyword">var</span> b64 = <span class="hljs-string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="</span>,
            o1,
            o2,
            o3,
            h1,
            h2,
            h3,
            h4,
            bits,
            i = <span class="hljs-number">0</span>,
            ac = <span class="hljs-number">0</span>,
            dec = <span class="hljs-string">""</span>,
            tmp_arr = [];

        <span class="hljs-keyword">if</span> (!data) {
            <span class="hljs-keyword">return</span> data;
        }

        data += <span class="hljs-string">''</span>;

        <span class="hljs-keyword">do</span> { <span class="hljs-comment">// unpack four hexets into three octets using index points in b64</span>
            h1 = b64.indexOf(data.charAt(i++));
            h2 = b64.indexOf(data.charAt(i++));
            h3 = b64.indexOf(data.charAt(i++));
            h4 = b64.indexOf(data.charAt(i++));

            bits = h1 &lt;&lt; <span class="hljs-number">18</span> | h2 &lt;&lt; <span class="hljs-number">12</span> | h3 &lt;&lt; <span class="hljs-number">6</span> | h4;

            o1 = bits &gt;&gt; <span class="hljs-number">16</span> &amp; <span class="hljs-number">0xff</span>;
            o2 = bits &gt;&gt; <span class="hljs-number">8</span> &amp; <span class="hljs-number">0xff</span>;
            o3 = bits &amp; <span class="hljs-number">0xff</span>;

            <span class="hljs-keyword">if</span> (h3 === <span class="hljs-number">64</span>) {
                tmp_arr[ac++] = <span class="hljs-built_in">String</span>.fromCharCode(o1);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (h4 === <span class="hljs-number">64</span>) {
                tmp_arr[ac++] = <span class="hljs-built_in">String</span>.fromCharCode(o1, o2);
            } <span class="hljs-keyword">else</span> {
                tmp_arr[ac++] = <span class="hljs-built_in">String</span>.fromCharCode(o1, o2, o3);
            }
        } <span class="hljs-keyword">while</span> (i &lt; data.length);
        dec = tmp_arr.join(<span class="hljs-string">''</span>);
        <span class="hljs-keyword">return</span> dec;
    };
}

<span class="hljs-keyword">var</span> getObjectLength = <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Object</span>.keys === <span class="hljs-string">'function'</span> ?
            <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">object</span>) </span>{
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.keys(object).length;
            } :
            <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">object</span>) </span>{
                <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, e;
                <span class="hljs-keyword">for</span> (e <span class="hljs-keyword">in</span> object) {
                    <span class="hljs-keyword">if</span> (object.hasOwnProperty(e)) {
                        i++;
                    }
                }
                <span class="hljs-keyword">return</span> i;
            },
</code></pre><p>&#x2F;**<br>PubSub implementation</p>
<p>@class<br>@name PubSub<br>*&#x2F;<br>        PubSub = function (context) {</p>
<pre><code class="hljs">        <span class="hljs-comment">/**  <span class="hljs-doctag">@preserve</span>
        -----------------------------------------------------------------------------------------------
        JavaScript PubSub library
        2012 (c) ddotsenko<span class="hljs-doctag">@willowsystems</span>.com
        based on Peter Higgins (dante<span class="hljs-doctag">@dojotoolkit</span>.org)
        Loosely based on Dojo publish/subscribe API, limited in scope. Rewritten blindly.
        Original is (c) Dojo Foundation 2004-2010. Released under either AFL or new BSD, see:
        http://dojofoundation.org/license for more information.
        -----------------------------------------------------------------------------------------------
        */</span>
        <span class="hljs-comment">/**
        <span class="hljs-doctag">@private</span>
        <span class="hljs-doctag">@fieldOf</span> PubSub
        */</span>
        this.topics = {};
        <span class="hljs-comment">/**
        Stores what will be `this` within the callback functions.

        <span class="hljs-doctag">@private</span>
        <span class="hljs-doctag">@fieldOf</span> PubSub#
        */</span>
        this.context = context;
        <span class="hljs-comment">/**
        Allows caller to emit an event and pass arguments to event listeners.
        <span class="hljs-doctag">@public</span>
        <span class="hljs-doctag">@function</span>
        <span class="hljs-doctag">@param</span> topic {String} Name of the channel on which to voice this event
        <span class="hljs-doctag">@param</span> args Any number of arguments you want to pass to the listeners of this event.
        <span class="hljs-doctag">@methodOf</span> PubSub#
        <span class="hljs-doctag">@name</span> publish
        */</span>
        this.publish = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(topic, args)</span> </span>{
            <span class="hljs-keyword">if</span> (this.topics[topic]) {
                <span class="hljs-keyword">var</span> currentTopic = this.topics[topic],
                    toremove = [],
                    fn,
                    i,
                    l,
                    pair,
                    emptyFunc = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{};
                args = <span class="hljs-keyword">Array</span>.prototype.slice.call(arguments, <span class="hljs-number">1</span>);
                <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, l = currentTopic.length; i &lt; l; i++) {
                    pair = currentTopic[i]; <span class="hljs-comment">// this is a [function, once_flag] array</span>
                    fn = pair[<span class="hljs-number">0</span>];
                    <span class="hljs-keyword">if</span> (pair[<span class="hljs-number">1</span>]) { <span class="hljs-comment">/* 'run once' flag set */</span>
                        pair[<span class="hljs-number">0</span>] = emptyFunc;
                        toremove.push(i);
                    }
                    fn.apply(this.context, args);
                }
                <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, l = toremove.length; i &lt; l; i++) {
                    currentTopic.splice(toremove[i], <span class="hljs-number">1</span>);
                }
            }
        };
        <span class="hljs-comment">/**
        Allows listener code to subscribe to channel and be called when data is available
        <span class="hljs-doctag">@public</span>
        <span class="hljs-doctag">@function</span>
        <span class="hljs-doctag">@param</span> topic {String} Name of the channel on which to voice this event
        <span class="hljs-doctag">@param</span> callback {Function} Executable (function pointer) that will be ran when event is voiced on this channel.
        <span class="hljs-doctag">@param</span> once {Boolean} (optional. False by default) Flag indicating if the function is to be triggered only once.
        <span class="hljs-doctag">@returns</span> {Object} A token object that cen be used for unsubscribing.
        <span class="hljs-doctag">@methodOf</span> PubSub#
        <span class="hljs-doctag">@name</span> subscribe
        */</span>
        this.subscribe = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(topic, callback, once)</span> </span>{
            <span class="hljs-keyword">if</span> (!this.topics[topic]) {
                this.topics[topic] = [[callback, once]];
            } <span class="hljs-keyword">else</span> {
                this.topics[topic].push([callback, once]);
            }
            <span class="hljs-keyword">return</span> {
                <span class="hljs-string">"topic"</span>: topic,
                <span class="hljs-string">"callback"</span>: callback
            };
        };
        <span class="hljs-comment">/**
        Allows listener code to unsubscribe from a channel
        <span class="hljs-doctag">@public</span>
        <span class="hljs-doctag">@function</span>
        <span class="hljs-doctag">@param</span> token {Object} A token object that was returned by `subscribe` method
        <span class="hljs-doctag">@methodOf</span> PubSub#
        <span class="hljs-doctag">@name</span> unsubscribe
        */</span>
        this.unsubscribe = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(token)</span> </span>{
            <span class="hljs-keyword">if</span> (this.topics[token.topic]) {
                <span class="hljs-keyword">var</span> currentTopic = this.topics[token.topic], i, l;

                <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, l = currentTopic.length; i &lt; l; i++) {
                    <span class="hljs-keyword">if</span> (currentTopic[i][<span class="hljs-number">0</span>] === token.callback) {
                        currentTopic.splice(i, <span class="hljs-number">1</span>);
                    }
                }
            }
        };
    };
</code></pre><p>&#x2F;<strong><br>@constructor<br>@private<br>*&#x2F;<br>    function jsPDF(orientation, unit, format, compressPdf) { &#x2F;</strong> String orientation, String unit, String format, Boolean compressed *&#x2F;</p>
<pre><code class="hljs">    <span class="hljs-comment">// Default parameter values</span>
    <span class="hljs-keyword">if</span> (typeof orientation === <span class="hljs-string">'undefined'</span>) {
        orientation = <span class="hljs-string">'p'</span>;
    } <span class="hljs-keyword">else</span> {
        orientation = orientation.toString().toLowerCase();
    }
    <span class="hljs-keyword">if</span> (typeof unit === <span class="hljs-string">'undefined'</span>) { unit = <span class="hljs-string">'mm'</span>; }
    <span class="hljs-keyword">if</span> (typeof format === <span class="hljs-string">'undefined'</span>) { format = <span class="hljs-string">'a4'</span>; }
    <span class="hljs-keyword">if</span> (typeof compressPdf === <span class="hljs-string">'undefined'</span> &amp;&amp; typeof zpipe === <span class="hljs-string">'undefined'</span>) { compressPdf = <span class="hljs-keyword">false</span>; }

    <span class="hljs-keyword">var</span> format_as_string = format.toString().toLowerCase(),
        version = <span class="hljs-string">'0.9.0rc2'</span>,
        content = [],
        content_length = <span class="hljs-number">0</span>,
        compress = compressPdf,
        pdfVersion = <span class="hljs-string">'1.3'</span>, <span class="hljs-comment">// PDF Version</span>
        pageFormats = { <span class="hljs-comment">// Size in pt of various paper formats</span>
            <span class="hljs-string">'a3'</span>: [<span class="hljs-number">841.89</span>, <span class="hljs-number">1190.55</span>],
            <span class="hljs-string">'a4'</span>: [<span class="hljs-number">595.28</span>, <span class="hljs-number">841.89</span>],
            <span class="hljs-string">'a5'</span>: [<span class="hljs-number">420.94</span>, <span class="hljs-number">595.28</span>],
            <span class="hljs-string">'letter'</span>: [<span class="hljs-number">612</span>, <span class="hljs-number">792</span>],
            <span class="hljs-string">'legal'</span>: [<span class="hljs-number">612</span>, <span class="hljs-number">1008</span>]
        },
        textColor = <span class="hljs-string">'0 g'</span>,
        drawColor = <span class="hljs-string">'0 G'</span>,
        page = <span class="hljs-number">0</span>,
        pages = [],
        objectNumber = <span class="hljs-number">2</span>, <span class="hljs-comment">// 'n' Current object number</span>
        outToPages = <span class="hljs-keyword">false</span>, <span class="hljs-comment">// switches where out() prints. outToPages true = push to pages obj. outToPages false = doc builder content</span>
        offsets = [], <span class="hljs-comment">// List of offsets. Activated and reset by buildDocument(). Pupulated by various calls buildDocument makes.</span>
        fonts = {}, <span class="hljs-comment">// collection of font objects, where key is fontKey - a dynamically created label for a given font.</span>
        fontmap = {}, <span class="hljs-comment">// mapping structure fontName &gt; fontStyle &gt; font key - performance layer. See addFont()</span>
        activeFontSize = <span class="hljs-number">16</span>,
        activeFontKey, <span class="hljs-comment">// will be string representing the KEY of the font as combination of fontName + fontStyle</span>
        lineWidth = <span class="hljs-number">0.200025</span>, <span class="hljs-comment">// 2mm</span>
        pageHeight,
        pageWidth,
        k, <span class="hljs-comment">// Scale factor</span>
        documentProperties = {<span class="hljs-string">'title'</span>: <span class="hljs-string">''</span>, <span class="hljs-string">'subject'</span>: <span class="hljs-string">''</span>, <span class="hljs-string">'author'</span>: <span class="hljs-string">''</span>, <span class="hljs-string">'keywords'</span>: <span class="hljs-string">''</span>, <span class="hljs-string">'creator'</span>: <span class="hljs-string">''</span>},
        lineCapID = <span class="hljs-number">0</span>,
        lineJoinID = <span class="hljs-number">0</span>,
        API = {},
        events = <span class="hljs-keyword">new</span> PubSub(API),
        tmp,
        plugin,
        <span class="hljs-comment">/////////////////////</span>
        <span class="hljs-comment">// Private functions</span>
        <span class="hljs-comment">/////////////////////</span>
        <span class="hljs-comment">// simplified (speedier) replacement for sprintf's %.2f conversion</span>
        f2 = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(number)</span> </span>{
            <span class="hljs-keyword">return</span> number.toFixed(<span class="hljs-number">2</span>);
        },
        <span class="hljs-comment">// simplified (speedier) replacement for sprintf's %.3f conversion</span>
        f3 = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(number)</span> </span>{
            <span class="hljs-keyword">return</span> number.toFixed(<span class="hljs-number">3</span>);
        },
        <span class="hljs-comment">// simplified (speedier) replacement for sprintf's %02d</span>
        padd2 = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(number)</span> </span>{
            <span class="hljs-keyword">var</span> n = (number).toFixed(<span class="hljs-number">0</span>);
            <span class="hljs-keyword">if</span> (number &lt; <span class="hljs-number">10</span>) {
                <span class="hljs-keyword">return</span> <span class="hljs-string">'0'</span> + n;
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> n;
            }
        },
        <span class="hljs-comment">// simplified (speedier) replacement for sprintf's %02d</span>
        padd10 = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(number)</span> </span>{
            <span class="hljs-keyword">var</span> n = (number).toFixed(<span class="hljs-number">0</span>);
            <span class="hljs-keyword">if</span> (n.length &lt; <span class="hljs-number">10</span>) {
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">Array</span>( <span class="hljs-number">11</span> - n.length ).join(<span class="hljs-string">'0'</span>) + n;
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> n;
            }
        },
        out = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(string)</span> </span>{
            <span class="hljs-keyword">if</span> (outToPages) { <span class="hljs-comment">/* set by beginPage */</span>
                pages[page].push(string);
            } <span class="hljs-keyword">else</span> {
                content.push(string);
                content_length += string.length + <span class="hljs-number">1</span>; <span class="hljs-comment">// +1 is for '\n' that will be used to join contents of content</span>
            }
        },
        newObject = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
            <span class="hljs-comment">// Begin a new object</span>
            objectNumber++;
            offsets[objectNumber] = content_length;
            out(objectNumber + <span class="hljs-string">' 0 obj'</span>);
            <span class="hljs-keyword">return</span> objectNumber;
        },
        putStream = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(str)</span> </span>{
            out(<span class="hljs-string">'stream'</span>);
            out(str);
            out(<span class="hljs-string">'endstream'</span>);
        },
        wPt,
        hPt,
        kids,
        i,
        putPages = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
            wPt = pageWidth * k;
            hPt = pageHeight * k;

            <span class="hljs-comment">// outToPages = false as set in endDocument(). out() writes to content.</span>

            <span class="hljs-keyword">var</span> n, p, arr, <span class="hljs-keyword">uint</span>, i, deflater, adler32;
            <span class="hljs-keyword">for</span> (n = <span class="hljs-number">1</span>; n &lt;= page; n++) {
                newObject();
                out(<span class="hljs-string">'&lt;&lt;/Type /Page'</span>);
                out(<span class="hljs-string">'/Parent 1 0 R'</span>);
                out(<span class="hljs-string">'/Resources 2 0 R'</span>);
                out(<span class="hljs-string">'/Contents '</span> + (objectNumber + <span class="hljs-number">1</span>) + <span class="hljs-string">' 0 R&gt;&gt;'</span>);
                out(<span class="hljs-string">'endobj'</span>);

                <span class="hljs-comment">// Page content</span>
                p = pages[n].join(<span class="hljs-string">'\n'</span>);
                newObject();
                <span class="hljs-keyword">if</span> (compress) {
                    arr = [];
                    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; p.length; ++i) {
                        arr[i] = p.charCodeAt(i);
                    }
                    adler32 = adler32cs.from(p);
                    deflater = <span class="hljs-keyword">new</span> Deflater(<span class="hljs-number">6</span>);
                    deflater.append(<span class="hljs-keyword">new</span> Uint8Array(arr));
                    p = deflater.flush();
                    arr = [<span class="hljs-keyword">new</span> Uint8Array([<span class="hljs-number">120</span>, <span class="hljs-number">156</span>]), <span class="hljs-keyword">new</span> Uint8Array(p),
                           <span class="hljs-keyword">new</span> Uint8Array([adler32 &amp; <span class="hljs-number">0xFF</span>, (adler32 &gt;&gt; <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xFF</span>, (adler32 &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xFF</span>, (adler32 &gt;&gt; <span class="hljs-number">24</span>) &amp; <span class="hljs-number">0xFF</span>])];
                    p = <span class="hljs-string">''</span>;
                    <span class="hljs-keyword">for</span> (i in arr) {
                        <span class="hljs-keyword">if</span> (arr.hasOwnProperty(i)) {
                            p += String.fromCharCode.apply(<span class="hljs-keyword">null</span>, arr[i]);
                        }
                    }
                    out(<span class="hljs-string">'&lt;&lt;/Length '</span> + p.length  + <span class="hljs-string">' /Filter [/FlateDecode]&gt;&gt;'</span>);
                } <span class="hljs-keyword">else</span> {
                    out(<span class="hljs-string">'&lt;&lt;/Length '</span> + p.length  + <span class="hljs-string">'&gt;&gt;'</span>);
                }
                putStream(p);
                out(<span class="hljs-string">'endobj'</span>);
            }
            offsets[<span class="hljs-number">1</span>] = content_length;
            out(<span class="hljs-string">'1 0 obj'</span>);
            out(<span class="hljs-string">'&lt;&lt;/Type /Pages'</span>);
            kids = <span class="hljs-string">'/Kids ['</span>;
            <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; page; i++) {
                kids += (<span class="hljs-number">3</span> + <span class="hljs-number">2</span> * i) + <span class="hljs-string">' 0 R '</span>;
            }
            out(kids + <span class="hljs-string">']'</span>);
            out(<span class="hljs-string">'/Count '</span> + page);
            out(<span class="hljs-string">'/MediaBox [0 0 '</span> + f2(wPt) + <span class="hljs-string">' '</span> + f2(hPt) + <span class="hljs-string">']'</span>);
            out(<span class="hljs-string">'&gt;&gt;'</span>);
            out(<span class="hljs-string">'endobj'</span>);
        },
        putFont = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(font)</span> </span>{
            font.objectNumber = newObject();
            out(<span class="hljs-string">'&lt;&lt;/BaseFont/'</span> + font.PostScriptName + <span class="hljs-string">'/Type/Font'</span>);
            <span class="hljs-keyword">if</span> (typeof font.encoding === <span class="hljs-string">'string'</span>) {
                out(<span class="hljs-string">'/Encoding/'</span> + font.encoding);
            }
            out(<span class="hljs-string">'/Subtype/Type1&gt;&gt;'</span>);
            out(<span class="hljs-string">'endobj'</span>);
        },
        putFonts = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">var</span> fontKey;
            <span class="hljs-keyword">for</span> (fontKey in fonts) {
                <span class="hljs-keyword">if</span> (fonts.hasOwnProperty(fontKey)) {
                    putFont(fonts[fontKey]);
                }
            }
        },
        putXobjectDict = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
            <span class="hljs-comment">// Loop through images, or other data objects</span>
            events.publish(<span class="hljs-string">'putXobjectDict'</span>);
        },
        putResourceDictionary = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
            out(<span class="hljs-string">'/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]'</span>);
            out(<span class="hljs-string">'/Font &lt;&lt;'</span>);
            <span class="hljs-comment">// Do this for each font, the '1' bit is the index of the font</span>
            <span class="hljs-keyword">var</span> fontKey;
            <span class="hljs-keyword">for</span> (fontKey in fonts) {
                <span class="hljs-keyword">if</span> (fonts.hasOwnProperty(fontKey)) {
                    out(<span class="hljs-string">'/'</span> + fontKey + <span class="hljs-string">' '</span> + fonts[fontKey].objectNumber + <span class="hljs-string">' 0 R'</span>);
                }
            }
            out(<span class="hljs-string">'&gt;&gt;'</span>);
            out(<span class="hljs-string">'/XObject &lt;&lt;'</span>);
            putXobjectDict();
            out(<span class="hljs-string">'&gt;&gt;'</span>);
        },
        putResources = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
            putFonts();
            events.publish(<span class="hljs-string">'putResources'</span>);
            <span class="hljs-comment">// Resource dictionary</span>
            offsets[<span class="hljs-number">2</span>] = content_length;
            out(<span class="hljs-string">'2 0 obj'</span>);
            out(<span class="hljs-string">'&lt;&lt;'</span>);
            putResourceDictionary();
            out(<span class="hljs-string">'&gt;&gt;'</span>);
            out(<span class="hljs-string">'endobj'</span>);
            events.publish(<span class="hljs-string">'postPutResources'</span>);
        },
        addToFontDictionary = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(fontKey, fontName, fontStyle)</span> </span>{
            <span class="hljs-comment">// this is mapping structure for quick font key lookup.</span>
            <span class="hljs-comment">// returns the KEY of the font (ex: "F1") for a given pair of font name and type (ex: "Arial". "Italic")</span>
            <span class="hljs-keyword">var</span> undef;
            <span class="hljs-keyword">if</span> (fontmap[fontName] === undef) {
                fontmap[fontName] = {}; <span class="hljs-comment">// fontStyle is a var interpreted and converted to appropriate string. don't wrap in quotes.</span>
            }
            fontmap[fontName][fontStyle] = fontKey;
        },
        <span class="hljs-comment">/**
        FontObject describes a particular font as member of an instnace of jsPDF

        It's a collection of properties like 'id' (to be used in PDF stream),
        'fontName' (font's family name), 'fontStyle' (font's style variant label)

        <span class="hljs-doctag">@class</span>
        <span class="hljs-doctag">@public</span>
        <span class="hljs-doctag">@property</span> id {String} PDF-document-instance-specific label assinged to the font.
        <span class="hljs-doctag">@property</span> PostScriptName {String} PDF specification full name for the font
        <span class="hljs-doctag">@property</span> encoding {Object} Encoding_name-to-Font_metrics_object mapping.
        <span class="hljs-doctag">@name</span> FontObject
        */</span>
        FontObject = {},
        addFont = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(PostScriptName, fontName, fontStyle, encoding)</span> </span>{
            <span class="hljs-keyword">var</span> fontKey = <span class="hljs-string">'F'</span> + (getObjectLength(fonts) + <span class="hljs-number">1</span>).toString(<span class="hljs-number">10</span>),
                <span class="hljs-comment">// This is FontObject</span>
                font = fonts[fontKey] = {
                    <span class="hljs-string">'id'</span>: fontKey,
                    <span class="hljs-comment">// , 'objectNumber':   will be set by putFont()</span>
                    <span class="hljs-string">'PostScriptName'</span>: PostScriptName,
                    <span class="hljs-string">'fontName'</span>: fontName,
                    <span class="hljs-string">'fontStyle'</span>: fontStyle,
                    <span class="hljs-string">'encoding'</span>: encoding,
                    <span class="hljs-string">'metadata'</span>: {}
                };

            addToFontDictionary(fontKey, fontName, fontStyle);

            events.publish(<span class="hljs-string">'addFont'</span>, font);

            <span class="hljs-keyword">return</span> fontKey;
        },
        addFonts = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{

            <span class="hljs-keyword">var</span> HELVETICA = <span class="hljs-string">"helvetica"</span>,
                TIMES = <span class="hljs-string">"times"</span>,
                COURIER = <span class="hljs-string">"courier"</span>,
                NORMAL = <span class="hljs-string">"normal"</span>,
                BOLD = <span class="hljs-string">"bold"</span>,
                ITALIC = <span class="hljs-string">"italic"</span>,
                BOLD_ITALIC = <span class="hljs-string">"bolditalic"</span>,
                encoding = <span class="hljs-string">'StandardEncoding'</span>,
                standardFonts = [
                    [<span class="hljs-string">'Helvetica'</span>, HELVETICA, NORMAL],
                    [<span class="hljs-string">'Helvetica-Bold'</span>, HELVETICA, BOLD],
                    [<span class="hljs-string">'Helvetica-Oblique'</span>, HELVETICA, ITALIC],
                    [<span class="hljs-string">'Helvetica-BoldOblique'</span>, HELVETICA, BOLD_ITALIC],
                    [<span class="hljs-string">'Courier'</span>, COURIER, NORMAL],
                    [<span class="hljs-string">'Courier-Bold'</span>, COURIER, BOLD],
                    [<span class="hljs-string">'Courier-Oblique'</span>, COURIER, ITALIC],
                    [<span class="hljs-string">'Courier-BoldOblique'</span>, COURIER, BOLD_ITALIC],
                    [<span class="hljs-string">'Times-Roman'</span>, TIMES, NORMAL],
                    [<span class="hljs-string">'Times-Bold'</span>, TIMES, BOLD],
                    [<span class="hljs-string">'Times-Italic'</span>, TIMES, ITALIC],
                    [<span class="hljs-string">'Times-BoldItalic'</span>, TIMES, BOLD_ITALIC]
                ],
                i,
                l,
                fontKey,
                parts;
            <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, l = standardFonts.length; i &lt; l; i++) {
                fontKey = addFont(
                    standardFonts[i][<span class="hljs-number">0</span>],
                    standardFonts[i][<span class="hljs-number">1</span>],
                    standardFonts[i][<span class="hljs-number">2</span>],
                    encoding
                );

                <span class="hljs-comment">// adding aliases for standard fonts, this time matching the capitalization</span>
                parts = standardFonts[i][<span class="hljs-number">0</span>].split(<span class="hljs-string">'-'</span>);
                addToFontDictionary(fontKey, parts[<span class="hljs-number">0</span>], parts[<span class="hljs-number">1</span>] || <span class="hljs-string">''</span>);
            }

            events.publish(<span class="hljs-string">'addFonts'</span>, {<span class="hljs-string">'fonts'</span>: fonts, <span class="hljs-string">'dictionary'</span>: fontmap});
        },
        <span class="hljs-comment">/**

        <span class="hljs-doctag">@public</span>
        <span class="hljs-doctag">@function</span>
        <span class="hljs-doctag">@param</span> text {String}
        <span class="hljs-doctag">@param</span> flags {Object} Encoding flags.
        <span class="hljs-doctag">@returns</span> {String} Encoded string
        */</span>
        to8bitStream = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(text, flags)</span> </span>{
            <span class="hljs-comment">/* PDF 1.3 spec:
            "For text strings encoded in Unicode, the first two bytes must be 254 followed by
            255, representing the Unicode byte order marker, U+FEFF. (This sequence conflicts
            with the PDFDocEncoding character sequence thorn ydieresis, which is unlikely
            to be a meaningful beginning of a word or phrase.) The remainder of the
            string consists of Unicode character codes, according to the UTF-16 encoding
            specified in the Unicode standard, version 2.0. Commonly used Unicode values
            are represented as 2 bytes per character, with the high-order byte appearing first
            in the string."

            In other words, if there are chars in a string with char code above 255, we
            recode the string to UCS2 BE - string doubles in length and BOM is prepended.

            HOWEVER!
            Actual *content* (body) text (as opposed to strings used in document properties etc)
            does NOT expect BOM. There, it is treated as a literal GID (Glyph ID)

            Because of Adobe's focus on "you subset your fonts!" you are not supposed to have
            a font that maps directly Unicode (UCS2 / UTF16BE) code to font GID, but you could
            fudge it with "Identity-H" encoding and custom CIDtoGID map that mimics Unicode
            code page. There, however, all characters in the stream are treated as GIDs,
            including BOM, which is the reason we need to skip BOM in content text (i.e. that
            that is tied to a font).

            To signal this "special" PDFEscape / to8bitStream handling mode,
            API.text() function sets (unless you overwrite it with manual values
            given to API.text(.., flags) )
                flags.autoencode = true
                flags.noBOM = true

            */</span>

            <span class="hljs-comment">/*
            `flags` properties relied upon:
            .sourceEncoding = string with encoding label.
                "Unicode" by default. = encoding of the incoming text.
                pass some non-existing encoding name
                (ex: 'Do not touch my strings! I know what I am doing.')
                to make encoding code skip the encoding step.
            .outputEncoding = Either valid PDF encoding name
                (must be supported by jsPDF font metrics, otherwise no encoding)
                or a JS object, where key = sourceCharCode, value = outputCharCode
                missing keys will be treated as: sourceCharCode === outputCharCode
            .noBOM
                See comment higher above for explanation for why this is important
            .autoencode
                See comment higher above for explanation for why this is important
            */</span>

            <span class="hljs-keyword">var</span> i, l, undef, sourceEncoding, encodingBlock, outputEncoding, newtext, isUnicode, ch, bch;

            <span class="hljs-keyword">if</span> (flags === undef) {
                flags = {};
            }

            sourceEncoding = flags.sourceEncoding ? sourceEncoding : <span class="hljs-string">'Unicode'</span>;

            outputEncoding = flags.outputEncoding;

            <span class="hljs-comment">// This 'encoding' section relies on font metrics format</span>
            <span class="hljs-comment">// attached to font objects by, among others,</span>
            <span class="hljs-comment">// "Willow Systems' standard_font_metrics plugin"</span>
            <span class="hljs-comment">// see jspdf.plugin.standard_font_metrics.js for format</span>
            <span class="hljs-comment">// of the font.metadata.encoding Object.</span>
            <span class="hljs-comment">// It should be something like</span>
            <span class="hljs-comment">//   .encoding = {'codePages':['WinANSI....'], 'WinANSI...':{code:code, ...}}</span>
            <span class="hljs-comment">//   .widths = {0:width, code:width, ..., 'fof':divisor}</span>
            <span class="hljs-comment">//   .kerning = {code:{previous_char_code:shift, ..., 'fof':-divisor},...}</span>
            <span class="hljs-keyword">if</span> ((flags.autoencode || outputEncoding) &amp;&amp;
                    fonts[activeFontKey].metadata &amp;&amp;
                    fonts[activeFontKey].metadata[sourceEncoding] &amp;&amp;
                    fonts[activeFontKey].metadata[sourceEncoding].encoding
                    ) {
                encodingBlock = fonts[activeFontKey].metadata[sourceEncoding].encoding;

                <span class="hljs-comment">// each font has default encoding. Some have it clearly defined.</span>
                <span class="hljs-keyword">if</span> (!outputEncoding &amp;&amp; fonts[activeFontKey].encoding) {
                    outputEncoding = fonts[activeFontKey].encoding;
                }

                <span class="hljs-comment">// Hmmm, the above did not work? Let's try again, in different place.</span>
                <span class="hljs-keyword">if</span> (!outputEncoding &amp;&amp; encodingBlock.codePages) {
                    outputEncoding = encodingBlock.codePages[<span class="hljs-number">0</span>]; <span class="hljs-comment">// let's say, first one is the default</span>
                }

                <span class="hljs-keyword">if</span> (typeof outputEncoding === <span class="hljs-string">'string'</span>) {
                    outputEncoding = encodingBlock[outputEncoding];
                }
                <span class="hljs-comment">// we want output encoding to be a JS Object, where</span>
                <span class="hljs-comment">// key = sourceEncoding's character code and</span>
                <span class="hljs-comment">// value = outputEncoding's character code.</span>
                <span class="hljs-keyword">if</span> (outputEncoding) {
                    isUnicode = <span class="hljs-keyword">false</span>;
                    newtext = [];
                    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, l = text.length; i &lt; l; i++) {
                        ch = outputEncoding[text.charCodeAt(i)];
                        <span class="hljs-keyword">if</span> (ch) {
                            newtext.push(
                                String.fromCharCode(ch)
                            );
                        } <span class="hljs-keyword">else</span> {
                            newtext.push(
                                text[i]
                            );
                        }

                        <span class="hljs-comment">// since we are looping over chars anyway, might as well</span>
                        <span class="hljs-comment">// check for residual unicodeness</span>
                        <span class="hljs-keyword">if</span> (newtext[i].charCodeAt(<span class="hljs-number">0</span>) &gt;&gt; <span class="hljs-number">8</span>) { <span class="hljs-comment">/* more than 255 */</span>
                            isUnicode = <span class="hljs-keyword">true</span>;
                        }
                    }
                    text = newtext.join(<span class="hljs-string">''</span>);
                }
            }

            i = text.length;
            <span class="hljs-comment">// isUnicode may be set to false above. Hence the triple-equal to undefined</span>
            <span class="hljs-keyword">while</span> (isUnicode === undef &amp;&amp; i !== <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">if</span> (text.charCodeAt(i - <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">8</span>) { <span class="hljs-comment">/* more than 255 */</span>
                    isUnicode = <span class="hljs-keyword">true</span>;
                }
                i--;
            }
            <span class="hljs-keyword">if</span> (!isUnicode) {
                <span class="hljs-keyword">return</span> text;
            } <span class="hljs-keyword">else</span> {
                newtext = flags.noBOM ? [] : [<span class="hljs-number">254</span>, <span class="hljs-number">255</span>];
                <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, l = text.length; i &lt; l; i++) {
                    ch = text.charCodeAt(i);
                    bch = ch &gt;&gt; <span class="hljs-number">8</span>; <span class="hljs-comment">// divide by 256</span>
                    <span class="hljs-keyword">if</span> (bch &gt;&gt; <span class="hljs-number">8</span>) { <span class="hljs-comment">/* something left after dividing by 256 second time */</span>
                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">"Character at position "</span> + i.toString(<span class="hljs-number">10</span>) + <span class="hljs-string">" of string '"</span> + text + <span class="hljs-string">"' exceeds 16bits. Cannot be encoded into UCS-2 BE"</span>);
                    }
                    newtext.push(bch);
                    newtext.push(ch - (bch &lt;&lt; <span class="hljs-number">8</span>));
                }
                <span class="hljs-keyword">return</span> String.fromCharCode.apply(undef, newtext);
            }
        },
        <span class="hljs-comment">// Replace '/', '(', and ')' with pdf-safe versions</span>
        pdfEscape = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(text, flags)</span> </span>{
            <span class="hljs-comment">// doing to8bitStream does NOT make this PDF display unicode text. For that</span>
            <span class="hljs-comment">// we also need to reference a unicode font and embed it - royal pain in the rear.</span>

            <span class="hljs-comment">// There is still a benefit to to8bitStream - PDF simply cannot handle 16bit chars,</span>
            <span class="hljs-comment">// which JavaScript Strings are happy to provide. So, while we still cannot display</span>
            <span class="hljs-comment">// 2-byte characters property, at least CONDITIONALLY converting (entire string containing)</span>
            <span class="hljs-comment">// 16bit chars to (USC-2-BE) 2-bytes per char + BOM streams we ensure that entire PDF</span>
            <span class="hljs-comment">// is still parseable.</span>
            <span class="hljs-comment">// This will allow immediate support for unicode in document properties strings.</span>
            <span class="hljs-keyword">return</span> to8bitStream(text, flags).replace(/\\/g, <span class="hljs-string">'\\\\'</span>).replace(/\(/g, <span class="hljs-string">'\\('</span>).replace(/\)/g, <span class="hljs-string">'\\)'</span>);
        },
        putInfo = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
            out(<span class="hljs-string">'/Producer (jsPDF '</span> + version + <span class="hljs-string">')'</span>);
            <span class="hljs-keyword">if</span> (documentProperties.title) {
                out(<span class="hljs-string">'/Title ('</span> + pdfEscape(documentProperties.title) + <span class="hljs-string">')'</span>);
            }
            <span class="hljs-keyword">if</span> (documentProperties.subject) {
                out(<span class="hljs-string">'/Subject ('</span> + pdfEscape(documentProperties.subject) + <span class="hljs-string">')'</span>);
            }
            <span class="hljs-keyword">if</span> (documentProperties.author) {
                out(<span class="hljs-string">'/Author ('</span> + pdfEscape(documentProperties.author) + <span class="hljs-string">')'</span>);
            }
            <span class="hljs-keyword">if</span> (documentProperties.keywords) {
                out(<span class="hljs-string">'/Keywords ('</span> + pdfEscape(documentProperties.keywords) + <span class="hljs-string">')'</span>);
            }
            <span class="hljs-keyword">if</span> (documentProperties.creator) {
                out(<span class="hljs-string">'/Creator ('</span> + pdfEscape(documentProperties.creator) + <span class="hljs-string">')'</span>);
            }
            <span class="hljs-keyword">var</span> created = <span class="hljs-keyword">new</span> Date();
            out(<span class="hljs-string">'/CreationDate (D:'</span> +
                [
                    created.getFullYear(),
                    padd2(created.getMonth() + <span class="hljs-number">1</span>),
                    padd2(created.getDate()),
                    padd2(created.getHours()),
                    padd2(created.getMinutes()),
                    padd2(created.getSeconds())
                ].join(<span class="hljs-string">''</span>) +
                <span class="hljs-string">')'</span>
                );
        },
        putCatalog = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
            out(<span class="hljs-string">'/Type /Catalog'</span>);
            out(<span class="hljs-string">'/Pages 1 0 R'</span>);
            <span class="hljs-comment">// @<span class="hljs-doctag">TODO:</span> Add zoom and layout modes</span>
            out(<span class="hljs-string">'/OpenAction [3 0 R /FitH null]'</span>);
            out(<span class="hljs-string">'/PageLayout /OneColumn'</span>);
            events.publish(<span class="hljs-string">'putCatalog'</span>);
        },
        putTrailer = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
            out(<span class="hljs-string">'/Size '</span> + (objectNumber + <span class="hljs-number">1</span>));
            out(<span class="hljs-string">'/Root '</span> + objectNumber + <span class="hljs-string">' 0 R'</span>);
            out(<span class="hljs-string">'/Info '</span> + (objectNumber - <span class="hljs-number">1</span>) + <span class="hljs-string">' 0 R'</span>);
        },
        beginPage = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
            page++;
            <span class="hljs-comment">// Do dimension stuff</span>
            outToPages = <span class="hljs-keyword">true</span>;
            pages[page] = [];
        },
        _addPage = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
            beginPage();
            <span class="hljs-comment">// Set line width</span>
            out(f2(lineWidth * k) + <span class="hljs-string">' w'</span>);
            <span class="hljs-comment">// Set draw color</span>
            out(drawColor);
            <span class="hljs-comment">// resurrecting non-default line caps, joins</span>
            <span class="hljs-keyword">if</span> (lineCapID !== <span class="hljs-number">0</span>) {
                out(lineCapID.toString(<span class="hljs-number">10</span>) + <span class="hljs-string">' J'</span>);
            }
            <span class="hljs-keyword">if</span> (lineJoinID !== <span class="hljs-number">0</span>) {
                out(lineJoinID.toString(<span class="hljs-number">10</span>) + <span class="hljs-string">' j'</span>);
            }
            events.publish(<span class="hljs-string">'addPage'</span>, {<span class="hljs-string">'pageNumber'</span>: page});
        },
        <span class="hljs-comment">/**
        Returns a document-specific font key - a label assigned to a
        font name + font type combination at the time the font was added
        to the font inventory.

        Font key is used as label for the desired font for a block of text
        to be added to the PDF document stream.
        <span class="hljs-doctag">@private</span>
        <span class="hljs-doctag">@function</span>
        <span class="hljs-doctag">@param</span> fontName {String} can be undefined on "falthy" to indicate "use current"
        <span class="hljs-doctag">@param</span> fontStyle {String} can be undefined on "falthy" to indicate "use current"
        <span class="hljs-doctag">@returns</span> {String} Font key.
        */</span>
        getFont = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(fontName, fontStyle)</span> </span>{
            <span class="hljs-keyword">var</span> key, undef;

            <span class="hljs-keyword">if</span> (fontName === undef) {
                fontName = fonts[activeFontKey].fontName;
            }
            <span class="hljs-keyword">if</span> (fontStyle === undef) {
                fontStyle = fonts[activeFontKey].fontStyle;
            }

            <span class="hljs-keyword">try</span> {
                key = fontmap[fontName][fontStyle]; <span class="hljs-comment">// returns a string like 'F3' - the KEY corresponding tot he font + type combination.</span>
            } <span class="hljs-keyword">catch</span> (e) {
                key = undef;
            }
            <span class="hljs-keyword">if</span> (!key) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">"Unable to look up font label for font '"</span> + fontName + <span class="hljs-string">"', '"</span> + fontStyle + <span class="hljs-string">"'. Refer to getFontList() for available fonts."</span>);
            }

            <span class="hljs-keyword">return</span> key;
        },
        buildDocument = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{

            outToPages = <span class="hljs-keyword">false</span>; <span class="hljs-comment">// switches out() to content</span>
            content = [];
            offsets = [];

            <span class="hljs-comment">// putHeader()</span>
            out(<span class="hljs-string">'%PDF-'</span> + pdfVersion);

            putPages();

            putResources();

            <span class="hljs-comment">// Info</span>
            newObject();
            out(<span class="hljs-string">'&lt;&lt;'</span>);
            putInfo();
            out(<span class="hljs-string">'&gt;&gt;'</span>);
            out(<span class="hljs-string">'endobj'</span>);

            <span class="hljs-comment">// Catalog</span>
            newObject();
            out(<span class="hljs-string">'&lt;&lt;'</span>);
            putCatalog();
            out(<span class="hljs-string">'&gt;&gt;'</span>);
            out(<span class="hljs-string">'endobj'</span>);

            <span class="hljs-comment">// Cross-ref</span>
            <span class="hljs-keyword">var</span> o = content_length, i;
            out(<span class="hljs-string">'xref'</span>);
            out(<span class="hljs-string">'0 '</span> + (objectNumber + <span class="hljs-number">1</span>));
            out(<span class="hljs-string">'0000000000 65535 f '</span>);
            <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= objectNumber; i++) {
                out(padd10(offsets[i]) + <span class="hljs-string">' 00000 n '</span>);
            }
            <span class="hljs-comment">// Trailer</span>
            out(<span class="hljs-string">'trailer'</span>);
            out(<span class="hljs-string">'&lt;&lt;'</span>);
            putTrailer();
            out(<span class="hljs-string">'&gt;&gt;'</span>);
            out(<span class="hljs-string">'startxref'</span>);
            out(o);
            out(<span class="hljs-string">'%%EOF'</span>);

            outToPages = <span class="hljs-keyword">true</span>;

            <span class="hljs-keyword">return</span> content.join(<span class="hljs-string">'\n'</span>);
        },
        getStyle = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(style)</span> </span>{
            <span class="hljs-comment">// see Path-Painting Operators of PDF spec</span>
            <span class="hljs-keyword">var</span> op = <span class="hljs-string">'S'</span>; <span class="hljs-comment">// stroke</span>
            <span class="hljs-keyword">if</span> (style === <span class="hljs-string">'F'</span>) {
                op = <span class="hljs-string">'f'</span>; <span class="hljs-comment">// fill</span>
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (style === <span class="hljs-string">'FD'</span> || style === <span class="hljs-string">'DF'</span>) {
                op = <span class="hljs-string">'B'</span>; <span class="hljs-comment">// both</span>
            }
            <span class="hljs-keyword">return</span> op;
        },

        <span class="hljs-comment">/**
        Generates the PDF document.
        Possible values:
            datauristring (alias dataurlstring) - Data-Url-formatted data returned as string.
            datauri (alias datauri) - Data-Url-formatted data pushed into current window's location (effectively reloading the window with contents of the PDF).

        If `type` argument is undefined, output is raw body of resulting PDF returned as a string.

        <span class="hljs-doctag">@param</span> {String} type A string identifying one of the possible output types.
        <span class="hljs-doctag">@param</span> {Object} options An object providing some additional signalling to PDF generator.
        <span class="hljs-doctag">@function</span>
        <span class="hljs-doctag">@returns</span> {jsPDF}
        <span class="hljs-doctag">@methodOf</span> jsPDF#
        <span class="hljs-doctag">@name</span> output
        */</span>
        output = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(type, options)</span> </span>{
            <span class="hljs-keyword">var</span> undef, data, length, <span class="hljs-keyword">array</span>, i, blob;
            <span class="hljs-keyword">switch</span> (type) {
            <span class="hljs-keyword">case</span> undef:
                <span class="hljs-keyword">return</span> buildDocument();
            <span class="hljs-keyword">case</span> <span class="hljs-string">'save'</span>:
                <span class="hljs-keyword">if</span> (navigator.getUserMedia) {
                    <span class="hljs-keyword">if</span> (window.URL === undefined) {
                        <span class="hljs-keyword">return</span> API.output(<span class="hljs-string">'dataurlnewwindow'</span>);
                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (window.URL.createObjectURL === undefined) {
                        <span class="hljs-keyword">return</span> API.output(<span class="hljs-string">'dataurlnewwindow'</span>);
                    }
                }
                data = buildDocument();

                <span class="hljs-comment">// Need to add the file to BlobBuilder as a Uint8Array</span>
                length = data.length;
                <span class="hljs-keyword">array</span> = <span class="hljs-keyword">new</span> Uint8Array(<span class="hljs-keyword">new</span> ArrayBuffer(length));

                <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; length; i++) {
                    <span class="hljs-keyword">array</span>[i] = data.charCodeAt(i);
                }

                blob = <span class="hljs-keyword">new</span> Blob([<span class="hljs-keyword">array</span>], {type: <span class="hljs-string">"application/pdf"</span>});

                saveAs(blob, options);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-string">'datauristring'</span>:
            <span class="hljs-keyword">case</span> <span class="hljs-string">'dataurlstring'</span>:
                <span class="hljs-keyword">return</span> <span class="hljs-string">'data:application/pdf;base64,'</span> + btoa(buildDocument());
            <span class="hljs-keyword">case</span> <span class="hljs-string">'datauri'</span>:
            <span class="hljs-keyword">case</span> <span class="hljs-string">'dataurl'</span>:
                document.location.href = <span class="hljs-string">'data:application/pdf;base64,'</span> + btoa(buildDocument());
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-string">'dataurlnewwindow'</span>:
                window.open(<span class="hljs-string">'data:application/pdf;base64,'</span> + btoa(buildDocument()));
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">default</span>:
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">'Output type "'</span> + type + <span class="hljs-string">'" is not supported.'</span>);
            }
            <span class="hljs-comment">// @<span class="hljs-doctag">TODO:</span> Add different output options</span>
        };

    <span class="hljs-keyword">if</span> (unit === <span class="hljs-string">'pt'</span>) {
        k = <span class="hljs-number">1</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (unit === <span class="hljs-string">'mm'</span>) {
        k = <span class="hljs-number">72</span> / <span class="hljs-number">25.4</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (unit === <span class="hljs-string">'cm'</span>) {
        k = <span class="hljs-number">72</span> / <span class="hljs-number">2.54</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (unit === <span class="hljs-string">'in'</span>) {
        k = <span class="hljs-number">72</span>;
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">throw</span> (<span class="hljs-string">'Invalid unit: '</span> + unit);
    }

    <span class="hljs-comment">// Dimensions are stored as user units and converted to points on output</span>
    <span class="hljs-keyword">if</span> (pageFormats.hasOwnProperty(format_as_string)) {
        pageHeight = pageFormats[format_as_string][<span class="hljs-number">1</span>] / k;
        pageWidth = pageFormats[format_as_string][<span class="hljs-number">0</span>] / k;
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">try</span> {
            pageHeight = format[<span class="hljs-number">1</span>];
            pageWidth = format[<span class="hljs-number">0</span>];
        } <span class="hljs-keyword">catch</span> (err) {
            <span class="hljs-keyword">throw</span> (<span class="hljs-string">'Invalid format: '</span> + format);
        }
    }

    <span class="hljs-keyword">if</span> (orientation === <span class="hljs-string">'p'</span> || orientation === <span class="hljs-string">'portrait'</span>) {
        orientation = <span class="hljs-string">'p'</span>;
        <span class="hljs-keyword">if</span> (pageWidth &gt; pageHeight) {
            tmp = pageWidth;
            pageWidth = pageHeight;
            pageHeight = tmp;
        }
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (orientation === <span class="hljs-string">'l'</span> || orientation === <span class="hljs-string">'landscape'</span>) {
        orientation = <span class="hljs-string">'l'</span>;
        <span class="hljs-keyword">if</span> (pageHeight &gt; pageWidth) {
            tmp = pageWidth;
            pageWidth = pageHeight;
            pageHeight = tmp;
        }
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">throw</span> (<span class="hljs-string">'Invalid orientation: '</span> + orientation);
    }



    <span class="hljs-comment">//---------------------------------------</span>
    <span class="hljs-comment">// Public API</span>

    <span class="hljs-comment">/*
    Object exposing internal API to plugins
    <span class="hljs-doctag">@public</span>
    */</span>
    API.internal = {
        <span class="hljs-string">'pdfEscape'</span>: pdfEscape,
        <span class="hljs-string">'getStyle'</span>: getStyle,
        <span class="hljs-comment">/**
        Returns {FontObject} describing a particular font.
        <span class="hljs-doctag">@public</span>
        <span class="hljs-doctag">@function</span>
        <span class="hljs-doctag">@param</span> fontName {String} (Optional) Font's family name
        <span class="hljs-doctag">@param</span> fontStyle {String} (Optional) Font's style variation name (Example:"Italic")
        <span class="hljs-doctag">@returns</span> {FontObject}
        */</span>
        <span class="hljs-string">'getFont'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> fonts[getFont.apply(API, arguments)]; },
        <span class="hljs-string">'getFontSize'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> activeFontSize;    },
        <span class="hljs-string">'btoa'</span>: btoa,
        <span class="hljs-string">'write'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(string1, string2, string3, etc)</span> </span>{
            out(
                arguments.length === <span class="hljs-number">1</span> ? string1 : <span class="hljs-keyword">Array</span>.prototype.join.call(arguments, <span class="hljs-string">' '</span>)
            );
        },
        <span class="hljs-string">'getCoordinateString'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(value)</span> </span>{
            <span class="hljs-keyword">return</span> f2(value * k);
        },
        <span class="hljs-string">'getVerticalCoordinateString'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(value)</span> </span>{
            <span class="hljs-keyword">return</span> f2((pageHeight - value) * k);
        },
        <span class="hljs-string">'collections'</span>: {},
        <span class="hljs-string">'newObject'</span>: newObject,
        <span class="hljs-string">'putStream'</span>: putStream,
        <span class="hljs-string">'events'</span>: events,
        <span class="hljs-comment">// ratio that you use in multiplication of a given "size" number to arrive to 'point'</span>
        <span class="hljs-comment">// units of measurement.</span>
        <span class="hljs-comment">// scaleFactor is set at initialization of the document and calculated against the stated</span>
        <span class="hljs-comment">// default measurement units for the document.</span>
        <span class="hljs-comment">// If default is "mm", k is the number that will turn number in 'mm' into 'points' number.</span>
        <span class="hljs-comment">// through multiplication.</span>
        <span class="hljs-string">'scaleFactor'</span>: k,
        <span class="hljs-string">'pageSize'</span>: {<span class="hljs-string">'width'</span>: pageWidth, <span class="hljs-string">'height'</span>: pageHeight},
        <span class="hljs-string">'output'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(type, options)</span> </span>{
            <span class="hljs-keyword">return</span> output(type, options);
        }
    };

    <span class="hljs-comment">/**
    Adds (and transfers the focus to) new page to the PDF document.
    <span class="hljs-doctag">@function</span>
    <span class="hljs-doctag">@returns</span> {jsPDF}

    <span class="hljs-doctag">@methodOf</span> jsPDF#
    <span class="hljs-doctag">@name</span> addPage
     */</span>
    API.addPage = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        _addPage();
        <span class="hljs-keyword">return</span> this;
    };

    <span class="hljs-comment">/**
    Adds text to page. Supports adding multiline text when 'text' argument is an Array of Strings.
    <span class="hljs-doctag">@function</span>
    <span class="hljs-doctag">@param</span> {String|Array} text String or array of strings to be added to the page. Each line is shifted one line down per font, spacing settings declared before this call.
    <span class="hljs-doctag">@param</span> {Number} x Coordinate (in units declared at inception of PDF document) against left edge of the page
    <span class="hljs-doctag">@param</span> {Number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page
    <span class="hljs-doctag">@param</span> {Object} flags Collection of settings signalling how the text must be encoded. Defaults are sane. If you think you want to pass some flags, you likely can read the source.
    <span class="hljs-doctag">@returns</span> {jsPDF}
    <span class="hljs-doctag">@methodOf</span> jsPDF#
    <span class="hljs-doctag">@name</span> text
     */</span>
    API.text = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(text, x, y, flags)</span> </span>{
        <span class="hljs-comment">/**
         * Inserts something like this into PDF
            BT
            /F1 16 Tf  % Font name + size
            16 TL % How many units down for next line in multiline text
            0 g % color
            28.35 813.54 Td % position
            (line one) Tj
            T* (line two) Tj
            T* (line three) Tj
            ET
        */</span>

        <span class="hljs-keyword">var</span> undef, _first, _second, _third, newtext, str, i;
        <span class="hljs-comment">// Pre-August-2012 the order of arguments was function(x, y, text, flags)</span>
        <span class="hljs-comment">// in effort to make all calls have similar signature like</span>
        <span class="hljs-comment">//   function(data, coordinates... , miscellaneous)</span>
        <span class="hljs-comment">// this method had its args flipped.</span>
        <span class="hljs-comment">// code below allows backward compatibility with old arg order.</span>
        <span class="hljs-keyword">if</span> (typeof text === <span class="hljs-string">'number'</span>) {
            _first = y;
            _second = text;
            _third = x;

            text = _first;
            x = _second;
            y = _third;
        }

        <span class="hljs-comment">// If there are any newlines in text, we assume</span>
        <span class="hljs-comment">// the user wanted to print multiple lines, so break the</span>
        <span class="hljs-comment">// text up into an array.  If the text is already an array,</span>
        <span class="hljs-comment">// we assume the user knows what they are doing.</span>
        <span class="hljs-keyword">if</span> (typeof text === <span class="hljs-string">'string'</span> &amp;&amp; text.match(/[\n\r]/)) {
            text = text.split(/\r\n|\r|\n/g);
        }

        <span class="hljs-keyword">if</span> (typeof flags === <span class="hljs-string">'undefined'</span>) {
            flags = {<span class="hljs-string">'noBOM'</span>: <span class="hljs-keyword">true</span>, <span class="hljs-string">'autoencode'</span>: <span class="hljs-keyword">true</span>};
        } <span class="hljs-keyword">else</span> {

            <span class="hljs-keyword">if</span> (flags.noBOM === undef) {
                flags.noBOM = <span class="hljs-keyword">true</span>;
            }

            <span class="hljs-keyword">if</span> (flags.autoencode === undef) {
                flags.autoencode = <span class="hljs-keyword">true</span>;
            }

        }

        <span class="hljs-keyword">if</span> (typeof text === <span class="hljs-string">'string'</span>) {
            str = pdfEscape(text, flags);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (text <span class="hljs-keyword">instanceof</span> <span class="hljs-keyword">Array</span>) {  <span class="hljs-comment">/* Array */</span>
            <span class="hljs-comment">// we don't want to destroy  original text array, so cloning it</span>
            newtext = text.concat();
            <span class="hljs-comment">// we do array.join('text that must not be PDFescaped")</span>
            <span class="hljs-comment">// thus, pdfEscape each component separately</span>
            <span class="hljs-keyword">for</span> (i = newtext.length - <span class="hljs-number">1</span>; i !== -<span class="hljs-number">1</span>; i--) {
                newtext[i] = pdfEscape(newtext[i], flags);
            }
            str = newtext.join(<span class="hljs-string">") Tj\nT* ("</span>);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">'Type of text must be string or Array. "'</span> + text + <span class="hljs-string">'" is not recognized.'</span>);
        }
        <span class="hljs-comment">// Using "'" ("go next line and render text" mark) would save space but would complicate our rendering code, templates</span>

        <span class="hljs-comment">// BT .. ET does NOT have default settings for Tf. You must state that explicitely every time for BT .. ET</span>
        <span class="hljs-comment">// if you want text transformation matrix (+ multiline) to work reliably (which reads sizes of things from font declarations)</span>
        <span class="hljs-comment">// Thus, there is NO useful, *reliable* concept of "default" font for a page.</span>
        <span class="hljs-comment">// The fact that "default" (reuse font used before) font worked before in basic cases is an accident</span>
        <span class="hljs-comment">// - readers dealing smartly with brokenness of jsPDF's markup.</span>
        out(
            <span class="hljs-string">'BT\n/'</span> +
                activeFontKey + <span class="hljs-string">' '</span> + activeFontSize + <span class="hljs-string">' Tf\n'</span> + <span class="hljs-comment">// font face, style, size</span>
                activeFontSize + <span class="hljs-string">' TL\n'</span> + <span class="hljs-comment">// line spacing</span>
                textColor +
                <span class="hljs-string">'\n'</span> + f2(x * k) + <span class="hljs-string">' '</span> + f2((pageHeight - y) * k) + <span class="hljs-string">' Td\n('</span> +
                str +
                <span class="hljs-string">') Tj\nET'</span>
        );
        <span class="hljs-keyword">return</span> this;
    };

    API.line = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(x1, y1, x2, y2)</span> </span>{
        out(
            f2(x1 * k) + <span class="hljs-string">' '</span> + f2((pageHeight - y1) * k) + <span class="hljs-string">' m '</span> +
                f2(x2 * k) + <span class="hljs-string">' '</span> + f2((pageHeight - y2) * k) + <span class="hljs-string">' l S'</span>
        );
        <span class="hljs-keyword">return</span> this;
    };

    <span class="hljs-comment">/**
    Adds series of curves (straight lines or cubic bezier curves) to canvas, starting at `x`, `y` coordinates.
    All data points in `lines` are relative to last line origin.
    `x`, `y` become x1,y1 for first line / curve in the set.
    For lines you only need to specify [x2, y2] - (ending point) vector against x1, y1 starting point.
    For bezier curves you need to specify [x2,y2,x3,y3,x4,y4] - vectors to control points 1, 2, ending point. All vectors are against the start of the curve - x1,y1.

    <span class="hljs-doctag">@example</span> .lines([[2,2],[-2,2],[1,1,2,2,3,3],[2,1]], 212,110, 10) // line, line, bezier curve, line
    <span class="hljs-doctag">@param</span> {Array} lines Array of *vector* shifts as pairs (lines) or sextets (cubic bezier curves).
    <span class="hljs-doctag">@param</span> {Number} x Coordinate (in units declared at inception of PDF document) against left edge of the page
    <span class="hljs-doctag">@param</span> {Number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page
    <span class="hljs-doctag">@param</span> {Number} scale (Defaults to [1.0,1.0]) x,y Scaling factor for all vectors. Elements can be any floating number Sub-one makes drawing smaller. Over-one grows the drawing. Negative flips the direction.
    <span class="hljs-doctag">@function</span>
    <span class="hljs-doctag">@returns</span> {jsPDF}
    <span class="hljs-doctag">@methodOf</span> jsPDF#
    <span class="hljs-doctag">@name</span> lines
     */</span>
    API.lines = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(lines, x, y, scale, style)</span> </span>{
        <span class="hljs-keyword">var</span> undef, _first, _second, _third, scalex, scaley, i, l, leg, x2, y2, x3, y3, x4, y4;

        <span class="hljs-comment">// Pre-August-2012 the order of arguments was function(x, y, lines, scale, style)</span>
        <span class="hljs-comment">// in effort to make all calls have similar signature like</span>
        <span class="hljs-comment">//   function(content, coordinateX, coordinateY , miscellaneous)</span>
        <span class="hljs-comment">// this method had its args flipped.</span>
        <span class="hljs-comment">// code below allows backward compatibility with old arg order.</span>
        <span class="hljs-keyword">if</span> (typeof lines === <span class="hljs-string">'number'</span>) {
            _first = y;
            _second = lines;
            _third = x;

            lines = _first;
            x = _second;
            y = _third;
        }

        style = getStyle(style);
        scale = scale === undef ? [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>] : scale;

        <span class="hljs-comment">// starting point</span>
        out(f3(x * k) + <span class="hljs-string">' '</span> + f3((pageHeight - y) * k) + <span class="hljs-string">' m '</span>);

        scalex = scale[<span class="hljs-number">0</span>];
        scaley = scale[<span class="hljs-number">1</span>];
        l = lines.length;
        <span class="hljs-comment">//, x2, y2 // bezier only. In page default measurement "units", *after* scaling</span>
        <span class="hljs-comment">//, x3, y3 // bezier only. In page default measurement "units", *after* scaling</span>
        <span class="hljs-comment">// ending point for all, lines and bezier. . In page default measurement "units", *after* scaling</span>
        x4 = x; <span class="hljs-comment">// last / ending point = starting point for first item.</span>
        y4 = y; <span class="hljs-comment">// last / ending point = starting point for first item.</span>

        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; l; i++) {
            leg = lines[i];
            <span class="hljs-keyword">if</span> (leg.length === <span class="hljs-number">2</span>) {
                <span class="hljs-comment">// simple line</span>
                x4 = leg[<span class="hljs-number">0</span>] * scalex + x4; <span class="hljs-comment">// here last x4 was prior ending point</span>
                y4 = leg[<span class="hljs-number">1</span>] * scaley + y4; <span class="hljs-comment">// here last y4 was prior ending point</span>
                out(f3(x4 * k) + <span class="hljs-string">' '</span> + f3((pageHeight - y4) * k) + <span class="hljs-string">' l'</span>);
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-comment">// bezier curve</span>
                x2 = leg[<span class="hljs-number">0</span>] * scalex + x4; <span class="hljs-comment">// here last x4 is prior ending point</span>
                y2 = leg[<span class="hljs-number">1</span>] * scaley + y4; <span class="hljs-comment">// here last y4 is prior ending point</span>
                x3 = leg[<span class="hljs-number">2</span>] * scalex + x4; <span class="hljs-comment">// here last x4 is prior ending point</span>
                y3 = leg[<span class="hljs-number">3</span>] * scaley + y4; <span class="hljs-comment">// here last y4 is prior ending point</span>
                x4 = leg[<span class="hljs-number">4</span>] * scalex + x4; <span class="hljs-comment">// here last x4 was prior ending point</span>
                y4 = leg[<span class="hljs-number">5</span>] * scaley + y4; <span class="hljs-comment">// here last y4 was prior ending point</span>
                out(
                    f3(x2 * k) + <span class="hljs-string">' '</span> +
                        f3((pageHeight - y2) * k) + <span class="hljs-string">' '</span> +
                        f3(x3 * k) + <span class="hljs-string">' '</span> +
                        f3((pageHeight - y3) * k) + <span class="hljs-string">' '</span> +
                        f3(x4 * k) + <span class="hljs-string">' '</span> +
                        f3((pageHeight - y4) * k) + <span class="hljs-string">' c'</span>
                );
            }
        }
        <span class="hljs-comment">// stroking / filling / both the path</span>
        out(style);
        <span class="hljs-keyword">return</span> this;
    };

    <span class="hljs-comment">/**
    Adds a rectangle to PDF

    <span class="hljs-doctag">@param</span> {Number} x Coordinate (in units declared at inception of PDF document) against left edge of the page
    <span class="hljs-doctag">@param</span> {Number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page
    <span class="hljs-doctag">@param</span> {Number} w Width (in units declared at inception of PDF document)
    <span class="hljs-doctag">@param</span> {Number} h Height (in units declared at inception of PDF document)
    <span class="hljs-doctag">@param</span> {String} style (Defaults to active fill/stroke style) A string signalling if stroke, fill or both are to be applied.
    <span class="hljs-doctag">@function</span>
    <span class="hljs-doctag">@returns</span> {jsPDF}
    <span class="hljs-doctag">@methodOf</span> jsPDF#
    <span class="hljs-doctag">@name</span> rect
     */</span>
    API.rect = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(x, y, w, h, style)</span> </span>{
        <span class="hljs-keyword">var</span> op = getStyle(style);
        out([
            f2(x * k),
            f2((pageHeight - y) * k),
            f2(w * k),
            f2(-h * k),
            <span class="hljs-string">'re'</span>,
            op
        ].join(<span class="hljs-string">' '</span>));
        <span class="hljs-keyword">return</span> this;
    };

    <span class="hljs-comment">/**
    Adds a triangle to PDF

    <span class="hljs-doctag">@param</span> {Number} x1 Coordinate (in units declared at inception of PDF document) against left edge of the page
    <span class="hljs-doctag">@param</span> {Number} y1 Coordinate (in units declared at inception of PDF document) against upper edge of the page
    <span class="hljs-doctag">@param</span> {Number} x2 Coordinate (in units declared at inception of PDF document) against left edge of the page
    <span class="hljs-doctag">@param</span> {Number} y2 Coordinate (in units declared at inception of PDF document) against upper edge of the page
    <span class="hljs-doctag">@param</span> {Number} x3 Coordinate (in units declared at inception of PDF document) against left edge of the page
    <span class="hljs-doctag">@param</span> {Number} y3 Coordinate (in units declared at inception of PDF document) against upper edge of the page
    <span class="hljs-doctag">@param</span> {String} style (Defaults to active fill/stroke style) A string signalling if stroke, fill or both are to be applied.
    <span class="hljs-doctag">@function</span>
    <span class="hljs-doctag">@returns</span> {jsPDF}
    <span class="hljs-doctag">@methodOf</span> jsPDF#
    <span class="hljs-doctag">@name</span> triangle
     */</span>
    API.triangle = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(x1, y1, x2, y2, x3, y3, style)</span> </span>{
        this.lines(
            [
                [ x2 - x1, y2 - y1 ], <span class="hljs-comment">// vector to point 2</span>
                [ x3 - x2, y3 - y2 ], <span class="hljs-comment">// vector to point 3</span>
                [ x1 - x3, y1 - y3 ] <span class="hljs-comment">// closing vector back to point 1</span>
            ],
            x1,
            y1, <span class="hljs-comment">// start of path</span>
            [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>],
            style
        );
        <span class="hljs-keyword">return</span> this;
    };

    <span class="hljs-comment">/**
    Adds a rectangle with rounded corners to PDF

    <span class="hljs-doctag">@param</span> {Number} x Coordinate (in units declared at inception of PDF document) against left edge of the page
    <span class="hljs-doctag">@param</span> {Number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page
    <span class="hljs-doctag">@param</span> {Number} w Width (in units declared at inception of PDF document)
    <span class="hljs-doctag">@param</span> {Number} h Height (in units declared at inception of PDF document)
    <span class="hljs-doctag">@param</span> {Number} rx Radius along x axis (in units declared at inception of PDF document)
    <span class="hljs-doctag">@param</span> {Number} rx Radius along y axis (in units declared at inception of PDF document)
    <span class="hljs-doctag">@param</span> {String} style (Defaults to active fill/stroke style) A string signalling if stroke, fill or both are to be applied.
    <span class="hljs-doctag">@function</span>
    <span class="hljs-doctag">@returns</span> {jsPDF}
    <span class="hljs-doctag">@methodOf</span> jsPDF#
    <span class="hljs-doctag">@name</span> roundedRect
    */</span>
    API.roundedRect = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(x, y, w, h, rx, ry, style)</span> </span>{
        <span class="hljs-keyword">var</span> MyArc = <span class="hljs-number">4</span> / <span class="hljs-number">3</span> * (Math.SQRT2 - <span class="hljs-number">1</span>);
        this.lines(
            [
                [ (w - <span class="hljs-number">2</span> * rx), <span class="hljs-number">0</span> ],
                [ (rx * MyArc), <span class="hljs-number">0</span>, rx, ry - (ry * MyArc), rx, ry ],
                [ <span class="hljs-number">0</span>, (h - <span class="hljs-number">2</span> * ry) ],
                [ <span class="hljs-number">0</span>, (ry * MyArc), -(rx * MyArc), ry, -rx, ry],
                [ (-w + <span class="hljs-number">2</span> * rx), <span class="hljs-number">0</span>],
                [ -(rx * MyArc), <span class="hljs-number">0</span>, -rx, -(ry * MyArc), -rx, -ry],
                [ <span class="hljs-number">0</span>, (-h + <span class="hljs-number">2</span> * ry)],
                [ <span class="hljs-number">0</span>, -(ry * MyArc), (rx * MyArc), -ry, rx, -ry]
            ],
            x + rx,
            y, <span class="hljs-comment">// start of path</span>
            [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>],
            style
        );
        <span class="hljs-keyword">return</span> this;
    };

    <span class="hljs-comment">/**
    Adds an ellipse to PDF

    <span class="hljs-doctag">@param</span> {Number} x Coordinate (in units declared at inception of PDF document) against left edge of the page
    <span class="hljs-doctag">@param</span> {Number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page
    <span class="hljs-doctag">@param</span> {Number} rx Radius along x axis (in units declared at inception of PDF document)
    <span class="hljs-doctag">@param</span> {Number} rx Radius along y axis (in units declared at inception of PDF document)
    <span class="hljs-doctag">@param</span> {String} style (Defaults to active fill/stroke style) A string signalling if stroke, fill or both are to be applied.
    <span class="hljs-doctag">@function</span>
    <span class="hljs-doctag">@returns</span> {jsPDF}
    <span class="hljs-doctag">@methodOf</span> jsPDF#
    <span class="hljs-doctag">@name</span> ellipse
     */</span>
    API.ellipse = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(x, y, rx, ry, style)</span> </span>{
        <span class="hljs-keyword">var</span> op = getStyle(style),
            lx = <span class="hljs-number">4</span> / <span class="hljs-number">3</span> * (Math.SQRT2 - <span class="hljs-number">1</span>) * rx,
            ly = <span class="hljs-number">4</span> / <span class="hljs-number">3</span> * (Math.SQRT2 - <span class="hljs-number">1</span>) * ry;

        out([
            f2((x + rx) * k),
            f2((pageHeight - y) * k),
            <span class="hljs-string">'m'</span>,
            f2((x + rx) * k),
            f2((pageHeight - (y - ly)) * k),
            f2((x + lx) * k),
            f2((pageHeight - (y - ry)) * k),
            f2(x * k),
            f2((pageHeight - (y - ry)) * k),
            <span class="hljs-string">'c'</span>
        ].join(<span class="hljs-string">' '</span>));
        out([
            f2((x - lx) * k),
            f2((pageHeight - (y - ry)) * k),
            f2((x - rx) * k),
            f2((pageHeight - (y - ly)) * k),
            f2((x - rx) * k),
            f2((pageHeight - y) * k),
            <span class="hljs-string">'c'</span>
        ].join(<span class="hljs-string">' '</span>));
        out([
            f2((x - rx) * k),
            f2((pageHeight - (y + ly)) * k),
            f2((x - lx) * k),
            f2((pageHeight - (y + ry)) * k),
            f2(x * k),
            f2((pageHeight - (y + ry)) * k),
            <span class="hljs-string">'c'</span>
        ].join(<span class="hljs-string">' '</span>));
        out([
            f2((x + lx) * k),
            f2((pageHeight - (y + ry)) * k),
            f2((x + rx) * k),
            f2((pageHeight - (y + ly)) * k),
            f2((x + rx) * k),
            f2((pageHeight - y) * k),
            <span class="hljs-string">'c'</span>,
            op
        ].join(<span class="hljs-string">' '</span>));
        <span class="hljs-keyword">return</span> this;
    };

    <span class="hljs-comment">/**
    Adds an circle to PDF

    <span class="hljs-doctag">@param</span> {Number} x Coordinate (in units declared at inception of PDF document) against left edge of the page
    <span class="hljs-doctag">@param</span> {Number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page
    <span class="hljs-doctag">@param</span> {Number} r Radius (in units declared at inception of PDF document)
    <span class="hljs-doctag">@param</span> {String} style (Defaults to active fill/stroke style) A string signalling if stroke, fill or both are to be applied.
    <span class="hljs-doctag">@function</span>
    <span class="hljs-doctag">@returns</span> {jsPDF}
    <span class="hljs-doctag">@methodOf</span> jsPDF#
    <span class="hljs-doctag">@name</span> circle
     */</span>
    API.circle = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(x, y, r, style)</span> </span>{
        <span class="hljs-keyword">return</span> this.ellipse(x, y, r, r, style);
    };

    <span class="hljs-comment">/**
    Adds a properties to the PDF document

    <span class="hljs-doctag">@param</span> {Object} A property_name-to-property_value object structure.
    <span class="hljs-doctag">@function</span>
    <span class="hljs-doctag">@returns</span> {jsPDF}
    <span class="hljs-doctag">@methodOf</span> jsPDF#
    <span class="hljs-doctag">@name</span> setProperties
     */</span>
    API.setProperties = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(properties)</span> </span>{
        <span class="hljs-comment">// copying only those properties we can render.</span>
        <span class="hljs-keyword">var</span> property;
        <span class="hljs-keyword">for</span> (property in documentProperties) {
            <span class="hljs-keyword">if</span> (documentProperties.hasOwnProperty(property) &amp;&amp; properties[property]) {
                documentProperties[property] = properties[property];
            }
        }
        <span class="hljs-keyword">return</span> this;
    };

    <span class="hljs-comment">/**
    Sets font size for upcoming text elements.

    <span class="hljs-doctag">@param</span> {Number} size Font size in points.
    <span class="hljs-doctag">@function</span>
    <span class="hljs-doctag">@returns</span> {jsPDF}
    <span class="hljs-doctag">@methodOf</span> jsPDF#
    <span class="hljs-doctag">@name</span> setFontSize
     */</span>
    API.setFontSize = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(size)</span> </span>{
        activeFontSize = size;
        <span class="hljs-keyword">return</span> this;
    };

    <span class="hljs-comment">/**
    Sets text font face, variant for upcoming text elements.
    See output of jsPDF.getFontList() for possible font names, styles.

    <span class="hljs-doctag">@param</span> {String} fontName Font name or family. Example: "times"
    <span class="hljs-doctag">@param</span> {String} fontStyle Font style or variant. Example: "italic"
    <span class="hljs-doctag">@function</span>
    <span class="hljs-doctag">@returns</span> {jsPDF}
    <span class="hljs-doctag">@methodOf</span> jsPDF#
    <span class="hljs-doctag">@name</span> setFont
     */</span>
    API.setFont = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(fontName, fontStyle)</span> </span>{
        activeFontKey = getFont(fontName, fontStyle);
        <span class="hljs-comment">// if font is not found, the above line blows up and we never go further</span>
        <span class="hljs-keyword">return</span> this;
    };

    <span class="hljs-comment">/**
    Switches font style or variant for upcoming text elements,
    while keeping the font face or family same.
    See output of jsPDF.getFontList() for possible font names, styles.

    <span class="hljs-doctag">@param</span> {String} style Font style or variant. Example: "italic"
    <span class="hljs-doctag">@function</span>
    <span class="hljs-doctag">@returns</span> {jsPDF}
    <span class="hljs-doctag">@methodOf</span> jsPDF#
    <span class="hljs-doctag">@name</span> setFontStyle
     */</span>
    API.setFontStyle = API.setFontType = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(style)</span> </span>{
        <span class="hljs-keyword">var</span> undef;
        activeFontKey = getFont(undef, style);
        <span class="hljs-comment">// if font is not found, the above line blows up and we never go further</span>
        <span class="hljs-keyword">return</span> this;
    };

    <span class="hljs-comment">/**
    Returns an object - a tree of fontName to fontStyle relationships available to
    active PDF document.

    <span class="hljs-doctag">@public</span>
    <span class="hljs-doctag">@function</span>
    <span class="hljs-doctag">@returns</span> {Object} Like {'times':['normal', 'italic', ... ], 'arial':['normal', 'bold', ... ], ... }
    <span class="hljs-doctag">@methodOf</span> jsPDF#
    <span class="hljs-doctag">@name</span> getFontList
    */</span>
    API.getFontList = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> iterate over fonts array or return copy of fontmap instead in case more are ever added.</span>
        <span class="hljs-keyword">var</span> <span class="hljs-keyword">list</span> = {},
            fontName,
            fontStyle,
            tmp;

        <span class="hljs-keyword">for</span> (fontName in fontmap) {
            <span class="hljs-keyword">if</span> (fontmap.hasOwnProperty(fontName)) {
                l
</code></pre></p>
										<div class="author">
											&mdash; commented <span title="May 13th 2013, 3:38:26 am">May 13th 2013</span>
											by <span class='authorname'>Abhishek Sharma</span>
										</div>
									</li>
								
								</ul>
							
						</footer>
						<aside class="vote-box">
							<div class="score"><span>0</span> Votes</div>
						</aside>
					</article>
				</li>
			
		</ul>
	
</article>

		</div>
		<div class="col-sm-3"></div>
	</div>
	<div class="row"><div class="signoff">The ownership of individual contributions to this community generated content is retained by the authors of their contributions.<br>All trademarks remain the property of the respective owner.</div></div>
</main>


</body>
</html>
